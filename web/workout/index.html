<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tracker Musculation Pro - Version Complète</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        /* Tout votre CSS original est ici (inchangé) */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #2196F3 0%, #4CAF50 100%);
            color: white;
            padding: 30px;
            text-align: center;
            position: relative;
        }        
        .sync-status {
            position: absolute;
            top: 15px;
            right: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(255,255,255,0.2);
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 0.9em;
        }
        
        .sync-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #4CAF50;
            animation: pulse 2s infinite;
        }
        
        .sync-indicator.syncing {
            background: #FFC107;
            animation: spin 1s linear infinite;
        }
        
        .sync-indicator.error {
            background: #f44336;
            animation: none;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        
        h1 {
            font-size: 2em;
            margin-bottom: 10px;
        }
        
        .date-selector {
            margin: 10px 0;
            padding: 10px;
            font-size: 1.1em;
            border: 2px solid white;
            border-radius: 10px;
            background: rgba(255,255,255,0.2);
            color: white;
            cursor: pointer;
        }
        
        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            padding: 20px;
            background: #f5f5f5;
            flex-wrap: wrap;
        }
        
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
        }
        
        .btn-primary {
            background: #2196F3;
            color: white;
        }
        
        .btn-secondary {
            background: #4CAF50;
            color: white;
        }
        
        .btn-danger {
            background: #f44336;
            color: white;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        .workout-selector {
            display: flex;
            justify-content: center;
            gap: 10px;
            padding: 20px;
            background: white;
            flex-wrap: wrap;
        }
        
        .workout-btn {
            padding: 15px 30px;
            border: 2px solid #ddd;
            background: white;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
            font-size: 1.1em;
        }
        
        .workout-btn:hover {
            border-color: #2196F3;
            background: #f0f8ff;
        }
        
        .workout-btn.active-push { 
            background: #ff5722; 
            color: white; 
            border-color: #ff5722;
        }
        
        .workout-btn.active-leg { 
            background: #9c27b0; 
            color: white; 
            border-color: #9c27b0;
        }
        
        .workout-btn.active-pull { 
            background: #2196F3; 
            color: white; 
            border-color: #2196F3;
        }
        
        .workout-btn.active-lower { 
            background: #ffc107; 
            color: white; 
            border-color: #ffc107;
        }
        
        .workout-btn.active-upper { 
            background: #4CAF50; 
            color: white; 
            border-color: #4CAF50;
        }

        /* STYLES AJOUTÉS POUR LES NOUVEAUX BOUTONS */
        .workout-btn.active-core_a { 
            background: #FF6B6B; 
            color: white; 
            border-color: #FF6B6B;
        }
        
        .workout-btn.active-core_b { 
            background: #4ECDC4; 
            color: white; 
            border-color: #4ECDC4;
        }
        
        .workout-btn.active-stats {
            background: linear-gradient(135deg, #FFD93D 0%, #FF6B6B 100%);
            color: white;
            border-color: #FFD93D;
        }
        
        .program-toggle {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
        }
        
        .toggle-btn {
            padding: 10px 30px;
            border: 2px solid #ddd;
            background: white;
            border-radius: 10px;
            cursor: pointer;
            font-size: 1.1em;
            font-weight: 600;
            transition: all 0.3s;
        }
        
        .toggle-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-color: #667eea;
        }
        
        .workout-table {
            padding: 20px;
            overflow-x: auto;
            display: none;
        }
        
        .workout-table.active {
            display: block;
        }
        
        table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            background: white;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
        }
        
        th {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 10px;
            text-align: left;
            font-weight: 600;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        td {
            padding: 12px 10px;
            border-bottom: 1px solid #eee;
        }
        
        tr:hover {
            background: #f8f9fa;
        }
        
        .exercise-name {
            font-weight: 600;
            color: #333;
        }
        
        input[type="number"] {
            width: 60px;
            padding: 8px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 1em;
            text-align: center;
            transition: all 0.3s;
        }
        
        input[type="number"]:focus {
            outline: none;
            border-color: #2196F3;
            background: #f0f8ff;
        }
        
        input.weight-input {
            width: 80px;
            background: #fff3e0;
            border-color: #ffb74d;
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            padding: 20px;
            background: #f5f5f5;
        }
        
        .stats.active {
            display: grid;
        }
        
        .stat-card {
            background: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }
        
        .stat-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 20px rgba(0,0,0,0.15);
        }
        
        .stat-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, #667eea, #764ba2);
        }
        
        .stat-value {
            font-size: 2em;
            font-weight: bold;
            color: #2196F3;
        }
        
        .stat-label {
            color: #666;
            margin-top: 5px;
        }
        
        .hidden {
            display: none !important;
        }
        
        /* Statistics Dashboard */
        .stats-dashboard {
            padding: 20px;
            display: none;
        }
        
        .stats-dashboard.active {
            display: block;
            animation: fadeIn 0.5s ease-in;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .dashboard-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #eee;
            padding-bottom: 10px;
        }
        
        .dashboard-tab {
            padding: 10px 20px;
            background: none;
            border: none;
            cursor: pointer;
            font-weight: 600;
            color: #666;
            transition: all 0.3s;
            position: relative;
        }
        
        .dashboard-tab.active {
            color: #2196F3;
        }
        
        .dashboard-tab.active::after {
            content: '';
            position: absolute;
            bottom: -12px;
            left: 0;
            right: 0;
            height: 3px;
            background: #2196F3;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
            animation: fadeIn 0.3s ease-in;
        }
        
        .metric-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .metric-card {
            background: white;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            position: relative;
            overflow: hidden;
        }
        
        .metric-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 4px;
            height: 100%;
            background: linear-gradient(180deg, #667eea, #764ba2);
        }
        
        .metric-title {
            font-size: 0.9em;
            color: #999;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
        }
        
        .metric-value {
            font-size: 2.5em;
            font-weight: bold;
            color: #333;
            margin-bottom: 5px;
        }
        
        .metric-change {
            font-size: 0.9em;
            padding: 4px 8px;
            border-radius: 20px;
            display: inline-block;
        }
        
        .metric-change.positive {
            background: #e8f5e9;
            color: #4caf50;
        }
        
        .metric-change.negative {
            background: #ffebee;
            color: #f44336;
        }
        
        .metric-change.neutral {
            background: #e3f2fd;
            color: #2196f3;
        }
        
        .chart-container {
            background: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            position: relative;
        }
        
        .chart-title {
            font-size: 1.2em;
            font-weight: 600;
            color: #333;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .chart-controls {
            display: flex;
            gap: 10px;
        }
        
        .chart-control {
            padding: 5px 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background: white;
            cursor: pointer;
            font-size: 0.9em;
        }
        
        .chart-control.active {
            background: #2196F3;
            color: white;
            border-color: #2196F3;
        }
        
        .insights-container {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            padding: 20px;
            border-radius: 15px;
            margin: 20px 0;
        }
        
        .insight-item {
            background: white;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 15px;
            transition: all 0.3s;
        }
        
        .insight-item:hover {
            transform: translateX(5px);
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
        }
        
        .insight-icon {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
        }
        
        .insight-icon.success {
            background: #e8f5e9;
            color: #4caf50;
        }
        
        .insight-icon.warning {
            background: #fff3e0;
            color: #ff9800;
        }
        
        .insight-icon.info {
            background: #e3f2fd;
            color: #2196f3;
        }
        
        .pr-table {
            width: 100%;
            margin-top: 20px;
        }
        
        .pr-table th {
            background: linear-gradient(135deg, #FFD93D 0%, #FF6B6B 100%);
        }
        
        .pr-badge {
            background: linear-gradient(135deg, #FFD93D 0%, #FF6B6B 100%);
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.8em;
            font-weight: 600;
            animation: pulse 2s infinite;
        }
        
        .category-header td {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-weight: 700;
            padding: 12px;
            font-size: 1.1em;
            text-align: left;
            border-bottom: 3px solid #fff;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        .goals-section {
            background: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            margin-top: 20px;
        }
        
        .goal-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 15px;
            border-bottom: 1px solid #eee;
            transition: all 0.3s;
        }
        
        .goal-item:hover {
            background: #f8f9fa;
        }
        
        .goal-item:last-child {
            border-bottom: none;
        }
        
        .goal-info {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .goal-icon {
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 1.2em;
        }
        
        .goal-details {
            flex: 1;
        }
        
        .goal-name {
            font-weight: 600;
            color: #333;
            margin-bottom: 5px;
        }
        
        .goal-progress {
            width: 200px;
            height: 10px;
            background: #e0e0e0;
            border-radius: 5px;
            overflow: hidden;
        }
        
        .goal-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #4caf50, #8bc34a);
            transition: width 0.5s ease;
        }
        
        .goal-value {
            font-size: 0.9em;
            color: #666;
            margin-left: 10px;
        }
        
        .calendar-container {
            background: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        
        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 5px;
            margin-top: 20px;
        }
        
        .calendar-day {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            font-size: 0.9em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
        }
        
        .calendar-day.empty {
            background: #f5f5f5;
        }
        
        .calendar-day.workout {
            background: linear-gradient(135deg, #4caf50, #8bc34a);
            color: white;
        }
        
        .calendar-day.rest {
            background: #fff;
            border: 2px solid #eee;
        }
        
        .calendar-day:hover {
            transform: scale(1.1);
            box-shadow: 0 3px 10px rgba(0,0,0,0.2);
        }
        
        .calendar-day-label {
            font-weight: bold;
            color: #999;
            text-align: center;
            font-size: 0.8em;
        }
        
        .prediction-section {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 30px;
            border-radius: 15px;
            color: white;
            margin: 20px 0;
        }
        
        .prediction-title {
            font-size: 1.5em;
            margin-bottom: 20px;
        }
        
        .prediction-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
        }
        
        .prediction-card {
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }
        
        .prediction-exercise {
            font-weight: 600;
            margin-bottom: 10px;
        }
        
        .prediction-value {
            font-size: 1.8em;
            font-weight: bold;
        }
        
        .prediction-date {
            font-size: 0.9em;
            opacity: 0.8;
            margin-top: 5px;
        }
        
        .strength-standards {
            background: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            margin: 20px 0;
        }
        
        .standard-bar {
            display: flex;
            margin: 15px 0;
            height: 40px;
            border-radius: 20px;
            overflow: hidden;
            background: #f5f5f5;
            position: relative;
        }
        
        .standard-segment {
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            font-size: 0.9em;
            flex: 1;
        }
        
        .standard-segment.beginner { background: #9e9e9e; }
        .standard-segment.novice { background: #2196f3; }
        .standard-segment.intermediate { background: #4caf50; }
        .standard-segment.advanced { background: #ff9800; }
        .standard-segment.elite { background: #f44336; }
        
        .standard-marker {
            position: absolute;
            top: -10px;
            width: 3px;
            height: 60px;
            background: #333;
            transform: translateX(-50%);
        }
        
        .standard-marker::after {
            content: 'Vous';
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            background: #333;
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.8em;
            white-space: nowrap;
        }
        
        .export-section {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
        }
        
        .export-menu {
            display: none;
            position: absolute;
            bottom: 70px;
            right: 0;
            background: white;
            border-radius: 10px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.2);
            padding: 10px;
            min-width: 200px;
        }
        
        .export-menu.active {
            display: block;
        }
        
        .export-option {
            padding: 10px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .export-option:hover {
            background: #f5f5f5;
        }
        
        .export-btn {
            padding: 15px;
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 1.5em;
            cursor: pointer;
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .export-btn:hover {
            transform: translateY(-3px) rotate(180deg);
            box-shadow: 0 8px 30px rgba(102, 126, 234, 0.6);
        }
        
        .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: #4CAF50;
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
            opacity: 0;
            transition: all 0.3s;
            z-index: 10000;
        }
        
        .toast.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }
        
        .modal {
            display: none;
            position: fixed;
            z-index: 10000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            animation: fadeIn 0.3s;
        }
        
        .modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 15px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            animation: slideUp 0.3s;
        }
        
        @keyframes slideUp {
            from { transform: translateY(50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        .modal-header {
            margin-bottom: 20px;
        }
        
        .modal-title {
            font-size: 1.5em;
            font-weight: 600;
            color: #333;
        }
        
        .modal-body {
            margin: 20px 0;
        }
        
        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 20px;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #333;
        }
        
        .form-input {
            width: 100%;
            padding: 10px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 1em;
        }
        
        .form-input:focus {
            outline: none;
            border-color: #2196F3;
        }
        
        @media (max-width: 768px) {
            .metric-grid {
                grid-template-columns: 1fr;
            }
            
            .dashboard-tabs {
                overflow-x: auto;
                white-space: nowrap;
            }
            
            .calendar-grid {
                gap: 2px;
            }
            
            .export-section {
                bottom: 10px;
                right: 10px;
            }
        }
        
        .help-btn {
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(255,255,255,0.2);
            color: white;
            border: 2px solid rgba(255,255,255,0.3);
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .help-btn:hover {
            background: rgba(255,255,255,0.3);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        .help-modal {
            display: none;
            position: fixed;
            z-index: 10001;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.6);
            animation: fadeIn 0.3s;
            overflow-y: auto;
        }
        
        .help-modal.active {
            display: flex;
            align-items: flex-start;
            justify-content: center;
            padding: 40px 20px;
        }
        
        .help-modal-content {
            background: white;
            padding: 40px;
            border-radius: 20px;
            max-width: 900px;
            width: 100%;
            animation: slideUp 0.3s;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        
        .help-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 3px solid #f0f0f0;
        }
        
        .help-modal-title {
            font-size: 2em;
            font-weight: 700;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .help-close-btn {
            background: #f44336;
            color: white;
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.5em;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }
        
        .help-close-btn:hover {
            transform: rotate(90deg) scale(1.1);
            background: #d32f2f;
        }
        
        .help-modal-body {
            color: #333;
            line-height: 1.8;
        }
        
        .help-modal-body h2 {
            color: #667eea;
            font-size: 1.6em;
            margin: 30px 0 15px 0;
            padding-top: 20px;
            border-top: 2px solid #f0f0f0;
        }
        
        .help-modal-body h2:first-child {
            margin-top: 0;
            padding-top: 0;
            border-top: none;
        }
        
        .help-modal-body h3 {
            color: #764ba2;
            font-size: 1.3em;
            margin: 20px 0 10px 0;
        }
        
        .help-modal-body h4 {
            color: #2196F3;
            font-size: 1.1em;
            margin: 15px 0 8px 0;
        }
        
        .help-modal-body code {
            background: #f5f5f5;
            padding: 2px 8px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            color: #e91e63;
            font-size: 0.9em;
        }
        
        .help-modal-body pre {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 8px;
            overflow-x: auto;
            border-left: 4px solid #667eea;
        }
        
        .help-modal-body pre code {
            background: none;
            padding: 0;
            color: #333;
        }
        
        .help-modal-body ul {
            margin: 15px 0;
            padding-left: 30px;
        }
        
        .help-modal-body li {
            margin: 8px 0;
        }
        
        .help-modal-body strong {
            color: #667eea;
            font-weight: 600;
        }
        
        .help-section {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1) 0%, rgba(118, 75, 162, 0.1) 100%);
            padding: 20px;
            border-radius: 12px;
            margin: 20px 0;
            border-left: 5px solid #667eea;
        }

        @media print {
            body {
                background: white;
            }
            
            .controls, .workout-selector, .program-toggle, .export-section, .help-btn {
                display: none !important;
            }
        }
        
        /* ============================================
           CHRONOMÈTRE TEMPS DE REPOS - STYLES
           ============================================ */
        
        /* Bouton flottant */
        .rest-timer-fab {
            position: fixed;
            bottom: 120px;
            right: 30px;
            width: 70px;
            height: 70px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
            transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            z-index: 1000;
            border: none;
        }
        
        .rest-timer-fab:hover {
            transform: scale(1.1);
            box-shadow: 0 12px 35px rgba(102, 126, 234, 0.6);
        }
        
        .rest-timer-fab:active {
            transform: scale(0.95);
        }
        
        .rest-timer-fab .fab-icon {
            font-size: 2em;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.2));
        }
        
        /* Modal du chronomètre */
        .rest-timer-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 10000;
            animation: fadeIn 0.3s;
        }
        
        .rest-timer-modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .rest-timer-content {
            background: white;
            border-radius: 20px;
            padding: 30px;
            min-width: 350px;
            max-width: 90%;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            animation: slideUp 0.3s;
            position: relative;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes slideUp {
            from { 
                transform: translateY(50px);
                opacity: 0;
            }
            to { 
                transform: translateY(0);
                opacity: 1;
            }
        }
        
        .rest-timer-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .rest-timer-title {
            font-size: 1.5em;
            font-weight: 700;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .rest-timer-close {
            background: none;
            border: none;
            font-size: 1.8em;
            cursor: pointer;
            color: #999;
            transition: all 0.2s;
            width: 35px;
            height: 35px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
        }
        
        .rest-timer-close:hover {
            background: #f0f0f0;
            color: #333;
            transform: rotate(90deg);
        }
        
        /* Affichage du temps */
        .rest-timer-display {
            text-align: center;
            margin: 30px 0;
        }
        
        .rest-timer-time {
            font-size: 5em;
            font-weight: 700;
            font-family: 'Courier New', monospace;
            transition: color 0.3s;
        }
        
        .rest-timer-time.green {
            color: #4CAF50;
        }
        
        .rest-timer-time.orange {
            color: #FF9800;
        }
        
        .rest-timer-time.red {
            color: #f44336;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        /* Barre de progression */
        .rest-timer-progress {
            width: 100%;
            height: 8px;
            background: #e0e0e0;
            border-radius: 10px;
            overflow: hidden;
            margin: 20px 0;
        }
        
        .rest-timer-progress-bar {
            height: 100%;
            transition: width 0.1s linear, background 0.3s;
            border-radius: 10px;
        }
        
        .rest-timer-progress-bar.green {
            background: linear-gradient(90deg, #4CAF50 0%, #8BC34A 100%);
        }
        
        .rest-timer-progress-bar.orange {
            background: linear-gradient(90deg, #FF9800 0%, #FFC107 100%);
        }
        
        .rest-timer-progress-bar.red {
            background: linear-gradient(90deg, #f44336 0%, #FF5722 100%);
        }
        
        /* Presets */
        .rest-timer-presets {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin: 20px 0;
        }
        
        .rest-timer-preset {
            padding: 15px;
            background: linear-gradient(135deg, #f5f5f5 0%, #e0e0e0 100%);
            border: 2px solid transparent;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
            text-align: center;
        }
        
        .rest-timer-preset:hover {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }
        
        .rest-timer-preset.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-color: #764ba2;
        }
        
        /* Boutons de contrôle */
        .rest-timer-controls {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        
        .rest-timer-btn {
            flex: 1;
            padding: 15px;
            border: none;
            border-radius: 10px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .rest-timer-btn-start {
            background: linear-gradient(135deg, #4CAF50 0%, #8BC34A 100%);
            color: white;
        }
        
        .rest-timer-btn-start:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(76, 175, 80, 0.4);
        }
        
        .rest-timer-btn-pause {
            background: linear-gradient(135deg, #FF9800 0%, #FFC107 100%);
            color: white;
        }
        
        .rest-timer-btn-pause:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 152, 0, 0.4);
        }
        
        .rest-timer-btn-reset {
            background: linear-gradient(135deg, #f44336 0%, #FF5722 100%);
            color: white;
        }
        
        .rest-timer-btn-reset:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(244, 67, 54, 0.4);
        }
        
        .rest-timer-btn:active {
            transform: translateY(0);
        }
        
        /* Badge d'état */
        .rest-timer-status {
            text-align: center;
            margin: 10px 0;
            font-size: 0.9em;
            color: #666;
            font-weight: 500;
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            .rest-timer-fab {
                width: 60px;
                height: 60px;
                bottom: 20px;
                right: 20px;
            }
            
            .rest-timer-content {
                min-width: unset;
                width: 90%;
                padding: 20px;
            }
            
            .rest-timer-time {
                font-size: 4em;
            }
            
            .rest-timer-presets {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        
        @media print {
            .rest-timer-fab, .rest-timer-modal {
                display: none !important;
            }
        }
        /* NOUVEAUX STYLES POUR LES CYCLES */
.cycle-card {
    background: linear-gradient(135deg, rgba(102, 126, 234, 0.1) 0%, rgba(118, 75, 162, 0.1) 100%);
    border: 2px solid #667eea;
    padding: 25px;
    border-radius: 15px;
    margin-bottom: 30px;
}

.cycle-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
}

.cycle-title {
    font-size: 1.5em;
    font-weight: bold;
    color: #667eea;
}

.cycle-weeks {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 15px;
    margin-top: 20px;
}

.week-card {
    background: white;
    padding: 15px;
    border-radius: 10px;
    text-align: center;
    box-shadow: 0 3px 10px rgba(0,0,0,0.1);
}

.week-card.current {
    border: 3px solid #4CAF50;
    background: #f1f8f4;
}

.week-number {
    font-size: 0.9em;
    color: #666;
    margin-bottom: 10px;
}

.week-volume {
    font-size: 2em;
    font-weight: bold;
    color: #2196F3;
}

.week-progress {
    margin-top: 10px;
    font-size: 0.9em;
}

.comparison-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 20px;
    margin-top: 20px;
}

.comparison-card {
    background: white;
    padding: 20px;
    border-radius: 10px;
    box-shadow: 0 3px 10px rgba(0,0,0,0.1);
}

.comparison-title {
    font-size: 1.1em;
    font-weight: 600;
    margin-bottom: 15px;
    color: #333;
}

.comparison-values {
    display: flex;
    justify-content: space-around;
    align-items: center;
    margin: 15px 0;
}

.comparison-value {
    text-align: center;
}

.comparison-label {
    font-size: 0.8em;
    color: #999;
}

.comparison-number {
    font-size: 1.8em;
    font-weight: bold;
    color: #2196F3;
}

.comparison-arrow {
    font-size: 2em;
}

@media (max-width: 768px) {
    .cycle-weeks {
        grid-template-columns: 1fr;
    }

    .comparison-grid {
        grid-template-columns: 1fr;
    }
}
    
    /* Phase 2: Records Grid */
    .records-grid {
        display: grid;
        gap: 15px;
        margin-top: 15px;
    }
    
    .record-category {
        background: rgba(255,255,255,0.05);
        padding: 15px;
        border-radius: 8px;
        border-left: 4px solid var(--primary-color);
    }
    
    .record-category-title {
        font-size: 1.1em;
        font-weight: 600;
        margin-bottom: 10px;
        color: var(--primary-color);
    }
    
    .record-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px 0;
        border-bottom: 1px solid rgba(255,255,255,0.05);
    }
    
    .record-item:last-child {
        border-bottom: none;
    }
    
    .record-exercise {
        font-weight: 500;
    }
    
    .record-value {
        color: #4CAF50;
        font-weight: 600;
    }
    
    .record-date {
        color: rgba(255,255,255,0.5);
        font-size: 0.85em;
        margin-left: 10px;
    }
    
    .record-badge {
        background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        color: white;
        padding: 2px 8px;
        border-radius: 12px;
        font-size: 0.75em;
        font-weight: 600;
        margin-left: 8px;
    }
    
    /* Phase 2: Balance Grid */
    .balance-grid {
        display: grid;
        gap: 20px;
        margin-top: 15px;
    }
    
    .balance-section {
        display: grid;
        grid-template-columns: 180px 1fr 80px;
        align-items: center;
        gap: 15px;
    }
    
    .balance-label {
        display: flex;
        align-items: center;
        gap: 10px;
        font-weight: 500;
    }
    
    .balance-emoji {
        font-size: 1.5em;
    }
    
    .balance-bar-container {
        background: rgba(255,255,255,0.1);
        height: 30px;
        border-radius: 15px;
        overflow: hidden;
        position: relative;
    }
    
    .balance-bar {
        height: 100%;
        border-radius: 15px;
        transition: width 0.5s ease, background 0.3s;
        display: flex;
        align-items: center;
        justify-content: flex-end;
        padding-right: 10px;
        font-weight: 600;
        font-size: 0.9em;
    }
    
    .push-bar {
        background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
    }
    
    .pull-bar {
        background: linear-gradient(90deg, #f093fb 0%, #f5576c 100%);
    }
    
    .legs-bar {
        background: linear-gradient(90deg, #4facfe 0%, #00f2fe 100%);
    }
    
    .balance-value {
        text-align: right;
        font-weight: 600;
        font-size: 1.1em;
    }
    
    .balance-alert {
        margin-top: 15px;
        padding: 12px;
        border-radius: 8px;
        background: rgba(255, 152, 0, 0.1);
        border-left: 4px solid #ff9800;
        display: none;
    }
    
    .balance-alert.visible {
        display: block;
    }
    
    .balance-alert strong {
        color: #ff9800;
    }
    
    /* Phase 2: Fatigue Card */
    .fatigue-card {
        margin-top: 15px;
        display: grid;
        grid-template-columns: 1fr 2fr;
        gap: 30px;
    }
    
    .fatigue-metric {
        text-align: center;
        padding: 20px;
        background: rgba(255,255,255,0.05);
        border-radius: 12px;
    }
    
    .fatigue-label {
        font-size: 0.9em;
        color: rgba(255,255,255,0.7);
        margin-bottom: 10px;
    }
    
    .fatigue-value {
        font-size: 3em;
        font-weight: 700;
        margin: 10px 0;
    }
    
    .fatigue-status {
        font-weight: 600;
        padding: 8px 16px;
        border-radius: 20px;
        display: inline-block;
        margin-top: 10px;
    }
    
    .fatigue-status.optimal {
        background: rgba(76, 175, 80, 0.2);
        color: #4CAF50;
    }
    
    .fatigue-status.warning {
        background: rgba(255, 152, 0, 0.2);
        color: #ff9800;
    }
    
    .fatigue-status.danger {
        background: rgba(244, 67, 54, 0.2);
        color: #f44336;
    }
    
    .fatigue-explanation {
        padding: 15px;
        background: rgba(255,255,255,0.03);
        border-radius: 8px;
    }
    
    .fatigue-explanation p {
        margin: 10px 0;
        line-height: 1.6;
    }
    
    .fatigue-explanation ul {
        list-style: none;
        padding: 0;
        margin: 15px 0 0 0;
    }
    
    .fatigue-explanation li {
        padding: 8px 0;
        line-height: 1.5;
    }
    
    @media (max-width: 768px) {
        .fatigue-card {
            grid-template-columns: 1fr;
        }
        
        .balance-section {
            grid-template-columns: 120px 1fr 60px;
        }
    }


        /* PHASE 3: Insights & Progressions */
        .insights-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 15px;
        }

        .insights-section {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 8px;
        }

        .insights-subtitle {
            font-size: 1.1em;
            margin-bottom: 15px;
            color: rgba(255, 255, 255, 0.9);
        }

        .progression-list, .attention-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .progression-item, .attention-item {
            background: rgba(255, 255, 255, 0.03);
            padding: 12px;
            border-radius: 6px;
            border-left: 3px solid;
        }

        .progression-item {
            border-left-color: #4CAF50;
        }

        .attention-item {
            border-left-color: #ff9800;
        }

        .progression-exercise {
            font-weight: 600;
            color: rgba(255, 255, 255, 0.95);
            margin-bottom: 5px;
        }

        .progression-change {
            font-size: 0.95em;
            color: rgba(255, 255, 255, 0.7);
        }

        .progression-positive {
            color: #4CAF50;
        }

        .progression-negative {
            color: #ff5252;
        }

        /* PHASE 3: Objectifs */
        .goals-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .goal-card {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid;
        }

        .goal-card.volume {
            border-left-color: #667eea;
        }

        .goal-card.pr {
            border-left-color: #f093fb;
        }

        .goal-card.frequency {
            border-left-color: #4facfe;
        }

        .goal-title {
            font-weight: 600;
            margin-bottom: 10px;
            color: rgba(255, 255, 255, 0.95);
        }

        .goal-progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }

        .goal-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            transition: width 0.3s ease;
        }

        .goal-status {
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.7);
        }

        .goal-empty {
            text-align: center;
            padding: 40px;
            color: rgba(255, 255, 255, 0.6);
        }

        /* PHASE 3: Ratio Libre/Guidé */
        .ratio-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .ratio-card {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 8px;
        }

        .ratio-exercise {
            font-weight: 600;
            color: rgba(255, 255, 255, 0.95);
            margin-bottom: 10px;
        }

        .ratio-comparison {
            display: flex;
            justify-content: space-between;
            gap: 10px;
            margin: 10px 0;
        }

        .ratio-program {
            flex: 1;
            text-align: center;
        }

        .ratio-label {
            font-size: 0.85em;
            color: rgba(255, 255, 255, 0.6);
            margin-bottom: 5px;
        }

        .ratio-value {
            font-size: 1.2em;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.95);
        }

        .ratio-verdict {
            font-size: 0.9em;
            padding: 8px;
            border-radius: 4px;
            text-align: center;
            margin-top: 10px;
        }

        .ratio-balanced {
            background: rgba(76, 175, 80, 0.2);
            color: #4CAF50;
        }

        .ratio-libre-better {
            background: rgba(102, 126, 234, 0.2);
            color: #667eea;
        }

        .ratio-guide-better {
            background: rgba(118, 75, 162, 0.2);
            color: #764ba2;
        }

        /* PHASE 3: Prédictions */
        .predictions-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .prediction-card {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 8px;
            border-left: 3px solid #667eea;
        }

        .prediction-exercise {
            font-weight: 600;
            color: rgba(255, 255, 255, 0.95);
            margin-bottom: 10px;
        }

        .prediction-current {
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 8px;
        }

        .prediction-target {
            font-size: 1.1em;
            font-weight: 600;
            color: #4CAF50;
            margin-bottom: 5px;
        }

        .prediction-timeline {
            font-size: 0.85em;
            color: rgba(255, 255, 255, 0.6);
        }

        .prediction-empty {
            text-align: center;
            padding: 40px;
            color: rgba(255, 255, 255, 0.6);
        }

        @media (max-width: 768px) {
            .insights-grid {
                grid-template-columns: 1fr;
            }

            .ratio-grid, .predictions-grid, .goals-grid {
                grid-template-columns: 1fr;
            }
        }

</style>
</head>
<body>
    <div class="container">
        <div class="header">
            <button class="help-btn" onclick="openHelpModal()">
                ❓ Aide
            </button>
            
            <div class="sync-status">
                <div class="sync-indicator" id="syncIndicator"></div>
                <span id="syncText">Synchronisé</span>
            </div>

            <h1>🏋️ Tracker Musculation Pro</h1>
            <input type="date" class="date-selector" id="dateSelector">
            <div id="currentStreak" style="margin-top: 10px; font-size: 0.9em; opacity: 0.9;">
                🔥 Série en cours: <span id="streakDays">0</span> jours
            </div>
        </div>
        
        <div class="program-toggle">
            <button class="toggle-btn active" onclick="setProgram('A')">Programme A (Libre)</button>
            <button class="toggle-btn" onclick="setProgram('B')">Programme B (Guidé)</button>
        </div>
        
        <div class="workout-selector">
            <button class="workout-btn" onclick="selectWorkout('push')">PUSH</button>
            <button class="workout-btn" onclick="selectWorkout('leg')">LEG</button>
            <button class="workout-btn" onclick="selectWorkout('pull')">PULL</button>
            <button class="workout-btn" onclick="selectWorkout('lower')">LOWER</button>
            <button class="workout-btn" onclick="selectWorkout('upper')">UPPER</button>
            <button class="workout-btn" onclick="selectWorkout('core_a')">CORE A</button>
            <button class="workout-btn" onclick="selectWorkout('core_b')">CORE B</button>
            <button class="workout-btn" onclick="showStats()">📊 STATS</button>
        </div>
        
        <div class="controls" id="workoutControls">
            <button class="btn btn-primary" onclick="saveData()">💾 Sauvegarder</button>
            <button class="btn btn-secondary" onclick="syncNow()">🔄 Synchroniser</button>
            <button class="btn btn-secondary" onclick="exportData()">📤 Exporter données</button>
            <button class="btn btn-secondary" onclick="document.getElementById('importFile').click()">📥 Importer</button>
            <input type="file" id="importFile" style="display:none" accept=".json" onchange="importData(event)">
            <button class="btn btn-danger" onclick="clearDay()">🗑️ Effacer ce jour</button>
        </div>
        
        <div class="stats" id="stats">
            <div class="stat-card">
                <div class="stat-value" id="totalVolume">0 kg</div>
                <div class="stat-label">Volume Total</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="totalSets">0</div>
                <div class="stat-label">Séries Complétées</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="totalReps">0</div>
                <div class="stat-label">Répétitions Totales</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="avgRest" style="font-size: 1.5em">-</div>
                <div class="stat-label">Intensité Moyenne</div>
            </div>
        </div>
        
        <div class="workout-table active" id="workoutTable"></div>
        
        <div class="stats-dashboard" id="statsDashboard">
            <div class="dashboard-tabs">
                <button class="dashboard-tab active" onclick="switchTab('overview')">Vue d'ensemble</button>
                <button class="dashboard-tab" onclick="switchTab('programA')">Programme A</button>
                <button class="dashboard-tab" onclick="switchTab('programB')">Programme B</button>
                <button class="dashboard-tab" onclick="switchTab('comparison')">Comparaison</button>
                <button class="dashboard-tab" onclick="switchTab('progress')">Progression</button>
                <button class="dashboard-tab" onclick="switchTab('records')">Records</button>
                <button class="dashboard-tab" onclick="switchTab('analysis')">Analyse</button>
                <button class="dashboard-tab" onclick="switchTab('goals')">Objectifs</button>
            </div>
            
            <div class="tab-content active" id="overview">
                <div class="metric-grid">
                    <div class="metric-card">
                        <div class="metric-title">Volume Hebdomadaire</div>
                        <div class="metric-value" id="weeklyVolume">0 kg</div>
                        <span class="metric-change positive" id="weeklyChange">+0%</span>
                    </div>
                    <div class="metric-card">
                        <div class="metric-title">Séances Cette Semaine</div>
                        <div class="metric-value" id="weeklyWorkouts">0</div>
                        <span class="metric-change neutral">Sur 5 prévues</span>
                    </div>
                    <div class="metric-card">
                        <div class="metric-title">Records Cette Semaine</div>
                        <div class="metric-value" id="weeklyPRs">0</div>
                        <span class="metric-change positive">Nouveaux PRs</span>
                    </div>
                    <div class="metric-card">
                        <div class="metric-title">Muscle le Plus Travaillé</div>
                        <div class="metric-value" id="topMuscle" style="font-size: 1.5em">-</div>
                        <span class="metric-change neutral" id="topMuscleVolume">0 kg</span>
                    </div>
                </div>

                <div class="chart-container">
                    <div class="chart-title">
                        <span>📈 Évolution du Volume</span>
                        <div class="chart-controls">
                            <button class="chart-control active" onclick="changeVolumeView('week')">Semaine</button>
                            <button class="chart-control" onclick="changeVolumeView('month')">Mois</button>
                            <button class="chart-control" onclick="changeVolumeView('year')">Année</button>
                        </div>
                    </div>
                    <canvas id="volumeChart" width="400" height="150"></canvas>
                </div>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                    <div class="chart-container">
                        <h3 class="chart-title">💪 Répartition par Muscle</h3>
                        <canvas id="muscleChart" width="200" height="200"></canvas>
                    </div>
                    <div class="chart-container">
                        <h3 class="chart-title">📊 Programme A vs B</h3>
                        <canvas id="programChart" width="200" height="200"></canvas>
                    </div>
                </div>
                
                <div class="calendar-container">
                    <h3 class="chart-title">📅 Calendrier d'Entraînement</h3>
                    <div id="calendarGrid" class="calendar-grid"></div>
                </div>
            </div>
            
            <!-- Nouveaux onglets pour les stats par programme -->
               <!-- NOUVEL ONGLET: Programme A -->
<div class="tab-content" id="programA">
    <h2 style="text-align: center; color: #667eea; margin-bottom: 20px;">
        📊 Programme A - Libre
    </h2>

    <!-- Cycle actuel Programme A -->
    <div id="cycleCardProgramA"></div>

    <!-- Comparaison inter-cycles Programme A -->
    <div class="chart-container">
        <h3 class="chart-title">🔄 Comparaison Inter-Cycles</h3>
        <div id="comparisonGridProgramA" class="comparison-grid"></div>
    </div>

    <!-- Volume par groupe musculaire Programme A -->
    <div class="chart-container">
        <h3 class="chart-title">💪 Volume par Groupe Musculaire</h3>
        <canvas id="muscleChartProgramA" width="400" height="200"></canvas>
    </div>

    <!-- Graphique progression long terme Programme A -->
    <div class="chart-container">
        <h3 class="chart-title">📈 Progression Long Terme</h3>
        <canvas id="progressionChartProgramA" width="400" height="200"></canvas>
    </div>

    <!-- 🏆 PHASE 2: Records par programme -->
    <div class="chart-container">
        <h3 class="chart-title">🏆 Records du Programme A (Libre)</h3>
        <div id="recordsGridProgramA" class="records-grid"></div>
    </div>

    <!-- ⚖️ PHASE 2: Équilibre Push/Pull/Legs -->
    <div class="chart-container">
        <h3 class="chart-title">⚖️ Équilibre Push/Pull/Legs</h3>
        <div class="balance-grid">
            <div class="balance-section">
                <div class="balance-label">
                    <span class="balance-emoji">💪</span>
                    <span>Push (Poussée)</span>
                </div>
                <div class="balance-bar-container">
                    <div class="balance-bar push-bar" id="pushBarProgramA" style="width: 33%"></div>
                </div>
                <div class="balance-value" id="pushValueProgramA">0%</div>
            </div>
            <div class="balance-section">
                <div class="balance-label">
                    <span class="balance-emoji">🔙</span>
                    <span>Pull (Traction)</span>
                </div>
                <div class="balance-bar-container">
                    <div class="balance-bar pull-bar" id="pullBarProgramA" style="width: 33%"></div>
                </div>
                <div class="balance-value" id="pullValueProgramA">0%</div>
            </div>
            <div class="balance-section">
                <div class="balance-label">
                    <span class="balance-emoji">🦵</span>
                    <span>Legs (Jambes)</span>
                </div>
                <div class="balance-bar-container">
                    <div class="balance-bar legs-bar" id="legsBarProgramA" style="width: 33%"></div>
                </div>
                <div class="balance-value" id="legsValueProgramA">0%</div>
            </div>
        </div>
        <div id="balanceAlertProgramA" class="balance-alert"></div>
    </div>

    <!-- 📉 PHASE 2: Indice de fatigue -->
    <div class="chart-container">
        <h3 class="chart-title">📉 Analyse de Fatigue du Cycle</h3>
        <div class="fatigue-card">
            <div class="fatigue-metric">
                <div class="fatigue-label">Indice de Fatigue</div>
                <div class="fatigue-value" id="fatigueIndexProgramA">-</div>
                <div class="fatigue-status" id="fatigueStatusProgramA"></div>
            </div>
            <div class="fatigue-explanation">
                <p><strong>Comment ça marche ?</strong></p>
                <p>Volume Semaine 3 / Volume Semaine 1</p>
                <ul>
                    <li>⚠️ &lt; 0.90 : Fatigue excessive, envisage un deload</li>
                    <li>✅ 0.95-1.05 : Récupération optimale</li>
                    <li>⚠️ &gt; 1.10 : Risque de surentraînement</li>
                </ul>
            </div>
        </div>
    </div>

    <!-- 🔥 PHASE 3: Top Progressions / Points d'attention -->
    <div class="chart-container">
        <h3 class="chart-title">🔥 Top Progressions & ⚠️ Points d'Attention</h3>
        <div class="insights-grid">
            <div class="insights-section">
                <h4 class="insights-subtitle">🔥 Top 3 Progressions</h4>
                <div id="topProgressionsProgramA" class="progression-list"></div>
            </div>
            <div class="insights-section">
                <h4 class="insights-subtitle">⚠️ Points d'Attention</h4>
                <div id="attentionPointsProgramA" class="attention-list"></div>
            </div>
        </div>
    </div>

    <!-- 🎯 PHASE 3: Objectifs Smart -->
    <div class="chart-container">
        <h3 class="chart-title">🎯 Objectifs du Programme A (Libre)</h3>
        <div id="goalsGridProgramA" class="goals-grid">
            <div class="goal-empty">
                <p>📝 Pas d'objectifs définis pour ce programme</p>
                <p style="font-size: 0.9em; color: rgba(255,255,255,0.6);">
                    Les objectifs peuvent être ajoutés dans l'onglet "Objectifs"
                </p>
            </div>
        </div>
    </div>

    <!-- ⚖️ PHASE 3: Ratio Libre/Guidé (uniquement pour Programme A) -->
    <div class="chart-container">
        <h3 class="chart-title">⚖️ Ratio Libre vs Guidé</h3>
        <p style="color: rgba(255,255,255,0.6); margin-bottom: 15px;">
            Comparaison des performances sur exercices similaires entre Programme A (Libre) et B (Guidé)
        </p>
        <div id="ratioGridProgramA" class="ratio-grid"></div>
    </div>

    <!-- 🔮 PHASE 3: Prédictions -->
    <div class="chart-container">
        <h3 class="chart-title">🔮 Prédictions de Performance</h3>
        <div id="predictionsProgramA" class="predictions-grid"></div>
    </div>

</div>

<!-- NOUVEL ONGLET: Programme B -->
<div class="tab-content" id="programB">
    <h2 style="text-align: center; color: #764ba2; margin-bottom: 20px;">
        📊 Programme B - Guidé
    </h2>

    <!-- Cycle actuel Programme B -->
    <div id="cycleCardProgramB"></div>

    <!-- Comparaison inter-cycles Programme B -->
    <div class="chart-container">
        <h3 class="chart-title">🔄 Comparaison Inter-Cycles</h3>
        <div id="comparisonGridProgramB" class="comparison-grid"></div>
    </div>

    <!-- Volume par groupe musculaire Programme B -->
    <div class="chart-container">
        <h3 class="chart-title">💪 Volume par Groupe Musculaire</h3>
        <canvas id="muscleChartProgramB" width="400" height="200"></canvas>
    </div>

    <!-- Graphique progression long terme Programme B -->
    <div class="chart-container">
        <h3 class="chart-title">📈 Progression Long Terme</h3>
        <canvas id="progressionChartProgramB" width="400" height="200"></canvas>
    </div>

    <!-- 🏆 PHASE 2: Records par programme -->
    <div class="chart-container">
        <h3 class="chart-title">🏆 Records du Programme B (Guidé)</h3>
        <div id="recordsGridProgramB" class="records-grid"></div>
    </div>

    <!-- ⚖️ PHASE 2: Équilibre Push/Pull/Legs -->
    <div class="chart-container">
        <h3 class="chart-title">⚖️ Équilibre Push/Pull/Legs</h3>
        <div class="balance-grid">
            <div class="balance-section">
                <div class="balance-label">
                    <span class="balance-emoji">💪</span>
                    <span>Push (Poussée)</span>
                </div>
                <div class="balance-bar-container">
                    <div class="balance-bar push-bar" id="pushBarProgramB" style="width: 33%"></div>
                </div>
                <div class="balance-value" id="pushValueProgramB">0%</div>
            </div>
            <div class="balance-section">
                <div class="balance-label">
                    <span class="balance-emoji">🔙</span>
                    <span>Pull (Traction)</span>
                </div>
                <div class="balance-bar-container">
                    <div class="balance-bar pull-bar" id="pullBarProgramB" style="width: 33%"></div>
                </div>
                <div class="balance-value" id="pullValueProgramB">0%</div>
            </div>
            <div class="balance-section">
                <div class="balance-label">
                    <span class="balance-emoji">🦵</span>
                    <span>Legs (Jambes)</span>
                </div>
                <div class="balance-bar-container">
                    <div class="balance-bar legs-bar" id="legsBarProgramB" style="width: 33%"></div>
                </div>
                <div class="balance-value" id="legsValueProgramB">0%</div>
            </div>
        </div>
        <div id="balanceAlertProgramB" class="balance-alert"></div>
    </div>

    <!-- 📉 PHASE 2: Indice de fatigue -->
    <div class="chart-container">
        <h3 class="chart-title">📉 Analyse de Fatigue du Cycle</h3>
        <div class="fatigue-card">
            <div class="fatigue-metric">
                <div class="fatigue-label">Indice de Fatigue</div>
                <div class="fatigue-value" id="fatigueIndexProgramB">-</div>
                <div class="fatigue-status" id="fatigueStatusProgramB"></div>
            </div>
            <div class="fatigue-explanation">
                <p><strong>Comment ça marche ?</strong></p>
                <p>Volume Semaine 3 / Volume Semaine 1</p>
                <ul>
                    <li>⚠️ &lt; 0.90 : Fatigue excessive, envisage un deload</li>
                    <li>✅ 0.95-1.05 : Récupération optimale</li>
                    <li>⚠️ &gt; 1.10 : Risque de surentraînement</li>
                </ul>
            </div>
        </div>
    </div>

    <!-- 🔥 PHASE 3: Top Progressions / Points d'attention -->
    <div class="chart-container">
        <h3 class="chart-title">🔥 Top Progressions & ⚠️ Points d'Attention</h3>
        <div class="insights-grid">
            <div class="insights-section">
                <h4 class="insights-subtitle">🔥 Top 3 Progressions</h4>
                <div id="topProgressionsProgramB" class="progression-list"></div>
            </div>
            <div class="insights-section">
                <h4 class="insights-subtitle">⚠️ Points d'Attention</h4>
                <div id="attentionPointsProgramB" class="attention-list"></div>
            </div>
        </div>
    </div>

    <!-- 🎯 PHASE 3: Objectifs Smart -->
    <div class="chart-container">
        <h3 class="chart-title">🎯 Objectifs du Programme B (Guidé)</h3>
        <div id="goalsGridProgramB" class="goals-grid">
            <div class="goal-empty">
                <p>📝 Pas d'objectifs définis pour ce programme</p>
                <p style="font-size: 0.9em; color: rgba(255,255,255,0.6);">
                    Les objectifs peuvent être ajoutés dans l'onglet "Objectifs"
                </p>
            </div>
        </div>
    </div>

    <!-- 🔮 PHASE 3: Prédictions -->
    <div class="chart-container">
        <h3 class="chart-title">🔮 Prédictions de Performance</h3>
        <div id="predictionsProgramB" class="predictions-grid"></div>
    </div>
</div>

<!-- NOUVEL ONGLET: Comparaison -->
<div class="tab-content" id="comparison">
    <h2 style="text-align: center; color: #2196F3; margin-bottom: 20px;">
        ⚖️ Comparaison Programme A vs B
    </h2>

    <!-- Métriques comparatives -->
    <div class="metric-grid">
        <div class="metric-card">
            <div class="metric-title">Volume Total - Programme A</div>
            <div class="metric-value" id="totalVolumeProgramA">0 kg</div>
            <span class="metric-change neutral">Libre</span>
        </div>
        <div class="metric-card">
            <div class="metric-title">Volume Total - Programme B</div>
            <div class="metric-value" id="totalVolumeProgramB">0 kg</div>
            <span class="metric-change neutral">Guidé</span>
        </div>
        <div class="metric-card">
            <div class="metric-title">Ratio B/A</div>
            <div class="metric-value" id="ratioBA">0x</div>
            <span class="metric-change neutral">Multiplicateur</span>
        </div>
        <div class="metric-card">
            <div class="metric-title">Séances Totales</div>
            <div class="metric-value" id="totalSessionsComparison">0</div>
            <span class="metric-change neutral" id="sessionsSplit">A: 0 | B: 0</span>
        </div>
    </div>

    <!-- Graphique comparatif -->
    <div class="chart-container">
        <h3 class="chart-title">📊 Évolution Comparative A vs B</h3>
        <canvas id="comparisonEvolutionChart" width="400" height="200"></canvas>
    </div>

    <!-- Comparaison par type de séance -->
    <div class="chart-container">
        <h3 class="chart-title">🏋️ Comparaison par Type de Séance</h3>
        <canvas id="workoutTypeComparisonChart" width="400" height="200"></canvas>
    </div>

</div>

            
            <div class="tab-content" id="progress">
                <div class="chart-container">
                    <h3 class="chart-title">📊 Top 5 Exercices (Volume Total)</h3>
                    <canvas id="exercisesChart" width="400" height="150"></canvas>
                </div>
                
                <div class="chart-container">
                    <h3 class="chart-title">📈 Progression des Exercices Clés</h3>
                    <canvas id="progressionChart" width="400" height="200"></canvas>
                </div>
                
                <div class="prediction-section">
                    <h3 class="prediction-title">🔮 Prédictions (basées sur votre progression)</h3>
                    <div class="prediction-grid" id="predictionGrid">
                        </div>
                </div>
                
                <div class="strength-standards">
                    <h3 class="chart-title">📏 Standards de Force (% poids de corps)</h3>
                    <div id="strengthStandards">
                        </div>
                </div>
            </div>
            
            <div class="tab-content" id="records">
                <div class="chart-container">
                    <h3 class="chart-title">🏆 Records Personnels</h3>
                    <table class="pr-table">
                        <thead>
                            <tr>
                                <th>Exercice</th>
                                <th>Meilleur Poids</th>
                                <th>Meilleures Reps</th>
                                <th>Meilleur Volume</th>
                                <th>Date</th>
                            </tr>
                        </thead>
                        <tbody id="prTableBody">
                            </tbody>
                    </table>
                </div>
                
                <div class="chart-container">
                    <h3 class="chart-title">🎯 Records du Mois</h3>
                    <div id="monthlyRecords" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                        </div>
                </div>
            </div>
            
            <div class="tab-content" id="analysis">
                <div class="insights-container">
                    <h3 style="margin-bottom: 20px;">💡 Insights & Recommandations</h3>
                    <div id="insightsList">
                        </div>
                </div>
                
                <div class="chart-container">
                    <h3 class="chart-title">⚖️ Équilibre Push/Pull/Legs</h3>
                    <canvas id="balanceChart" width="400" height="150"></canvas>
                </div>
                
                <div class="chart-container">
                    <h3 class="chart-title">📊 Analyse de Fatigue</h3>
                    <canvas id="fatigueChart" width="400" height="150"></canvas>
                </div>
                
                <div class="chart-container">
                    <h3 class="chart-title">🎯 Zones à Améliorer</h3>
                    <div id="improvementAreas" style="display: grid; gap: 10px;">
                        </div>
                </div>
            </div>
            
            <div class="tab-content" id="goals">
                <button class="btn btn-primary" onclick="openGoalModal()" style="margin-bottom: 20px;">
                    ➕ Ajouter un Objectif
                </button>
                
                <div class="goals-section">
                    <h3 class="chart-title">🎯 Objectifs Actifs</h3>
                    <div id="goalsList">
                        </div>
                </div>
                
                <div class="goals-section">
                    <h3 class="chart-title">✅ Objectifs Atteints</h3>
                    <div id="completedGoalsList">
                        </div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="export-section">
        <div class="export-menu" id="exportMenu">
            <div class="export-option" onclick="exportPDF()">📄 Export PDF</div>
            <div class="export-option" onclick="exportCSV()">📊 Export CSV</div>
            <div class="export-option" onclick="shareStats()">📱 Partager Stats</div>
        </div>
        <button class="export-btn" onclick="toggleExportMenu()" id="exportBtn">
            📤
        </button>
    </div>
    
    <div class="modal" id="goalModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Ajouter un Objectif</h2>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label">Exercice</label>
                    <select class="form-input" id="goalExercise">
                        <option value="">Sélectionner un exercice</option>
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label">Type d'objectif</label>
                    <select class="form-input" id="goalType">
                        <option value="weight">Poids (kg)</option>
                        <option value="reps">Répétitions</option>
                        <option value="volume">Volume (kg)</option>
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label">Valeur cible</label>
                    <input type="number" class="form-input" id="goalValue" placeholder="Ex: 100">
                </div>
                <div class="form-group">
                    <label class="form-label">Date limite</label>
                    <input type="date" class="form-input" id="goalDate">
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeGoalModal()">Annuler</button>
                <button class="btn btn-primary" onclick="saveGoal()">Sauvegarder</button>
            </div>
        </div>
    </div>
    
    <!-- Modale d'aide -->
    <div class="help-modal" id="helpModal">
        <div class="help-modal-content">
            <div class="help-modal-header">
                <h2 class="help-modal-title">📚 Guide d'utilisation</h2>
                <button class="help-close-btn" onclick="closeHelpModal()">×</button>
            </div>
            <div class="help-modal-body">
                
                <h2>📊 1. Calcul de l'Intensité Moyenne</h2>
                
                <div class="help-section">
                    <h3>Qu'est-ce que ce chiffre représente ?</h3>
                    <p>L'intensité affichée dans ton tracker n'est <strong>pas vraiment une "moyenne"</strong> mais plutôt ton <strong>intensité maximale relative</strong> de la séance, exprimée en <strong>pourcentage de ton poids de corps</strong>.</p>
                </div>
                
                <h3>Comment c'est calculé ?</h3>
                <p>Le calcul se fait en 3 étapes :</p>
                
                <h4>Étape 1 : Calcul du 1RM (One Rep Max)</h4>
                <p>Pour chaque série effectuée, le tracker calcule ton <strong>1RM estimé</strong> (le poids maximum que tu pourrais soulever une seule fois) en utilisant la <strong>formule de Brzycki</strong> :</p>
                <pre><code>1RM = Poids / (1.0278 - 0.0278 × Reps)</code></pre>
                
                <h4>Étape 2 : Sélection du maximum</h4>
                <p>Le tracker garde le <strong>plus grand</strong> de tous ces 1RM calculés pendant ta séance.</p>
                
                <h4>Étape 3 : Conversion en pourcentage du poids de corps</h4>
                <pre><code>Intensité affichée = (Max 1RM / 90 kg) × 100</code></pre>
                
                <h3>Exemple concret</h3>
                <p>Imaginons que tu fais <strong>100 kg × 8 répétitions</strong> au développé couché :</p>
                <ol>
                    <li><strong>Calcul du 1RM</strong> : 100 / (1.0278 - 0.0278 × 8) = 100 / 0.8054 ≈ 124 kg</li>
                    <li><strong>C'est le max de ta séance</strong> : 124 kg</li>
                    <li><strong>Conversion en %</strong> : (124 / 90) × 100 = 138%</li>
                </ol>
                <p><strong>Résultat affiché : 138%</strong></p>
                
                <div class="help-section">
                    <h3>Comment interpréter ce chiffre ?</h3>
                    <ul>
                        <li><strong>&lt; 100%</strong> : Séance légère, travail d'endurance</li>
                        <li><strong>100-150%</strong> : Intensité modérée à élevée, zone de travail classique</li>
                        <li><strong>150-200%</strong> : Intensité très élevée, travail de force</li>
                        <li><strong>&gt; 200%</strong> : Intensité maximale, travail de force pure</li>
                    </ul>
                    <p>⚠️ <strong>Note</strong> : Ce chiffre dépend de ton poids de corps qui est actuellement codé en dur à 90 kg dans le tracker.</p>
                </div>
                
                <h2>🎯 2. Regroupement des exercices par catégories musculaires</h2>
                
                <h3>Catégories disponibles</h3>
                <p>Dans la section <strong>Stats / Records</strong>, tous les exercices sont maintenant regroupés par catégories musculaires :</p>
                <ul>
                    <li>🏋️ <strong>Pectoraux</strong></li>
                    <li>💪 <strong>Dos</strong></li>
                    <li>🔺 <strong>Épaules</strong></li>
                    <li>💪 <strong>Bras (Biceps)</strong></li>
                    <li>💪 <strong>Bras (Triceps)</strong></li>
                    <li>🦵 <strong>Quadriceps</strong></li>
                    <li>🦵 <strong>Ischio-jambiers</strong></li>
                    <li>🍑 <strong>Fessiers/Adducteurs</strong></li>
                    <li>👟 <strong>Mollets</strong></li>
                    <li>🔄 <strong>Lombaires</strong></li>
                    <li>📦 <strong>Abdominaux</strong></li>
                </ul>
                
                <div class="help-section">
                    <h3>Avantages</h3>
                    <ul>
                        <li>✅ <strong>Recherche facilitée</strong> : Trouve rapidement tous les records pour un groupe musculaire spécifique</li>
                        <li>✅ <strong>Organisation claire</strong> : Chaque catégorie a son propre en-tête coloré</li>
                        <li>✅ <strong>Tri intelligent</strong> : Dans chaque catégorie, les exercices sont triés par volume total (du plus élevé au plus faible)</li>
                        <li>✅ <strong>Hiérarchie visuelle</strong> : Les exercices sont indentés sous leur catégorie</li>
                    </ul>
                </div>
                
                <h2>🔄 3. Synchronisation des données</h2>
                <p>Le tracker sauvegarde automatiquement tes données :</p>
                <ul>
                    <li><strong>Sauvegarde locale</strong> : Dans le navigateur (localStorage)</li>
                    <li><strong>Synchronisation serveur</strong> : Automatique après chaque modification</li>
                    <li><strong>Export/Import</strong> : Tu peux exporter tes données en JSON pour sauvegarde externe</li>
                </ul>
                
                <h2>📈 4. Statistiques disponibles</h2>
                <p>Dans l'onglet <strong>📊 STATS</strong>, tu as accès à :</p>
                <ul>
                    <li><strong>Vue d'ensemble</strong> : Volume hebdo, nombre de séances, série en cours</li>
                    <li><strong>Progrès</strong> : Graphiques de progression par exercice</li>
                    <li><strong>Records</strong> : Tous tes records personnels groupés par muscle</li>
                    <li><strong>Analyse</strong> : Équilibre push/pull/legs, insights personnalisés</li>
                    <li><strong>Objectifs</strong> : Suivi de tes objectifs avec barre de progression</li>
                </ul>
                
                <div class="help-section">
                    <h3>💡 Astuce</h3>
                    <p>Utilise le bouton <strong>🔄 Synchroniser</strong> régulièrement pour être sûr que tes données sont bien sauvegardées sur le serveur !</p>
                </div>
                
            </div>
        </div>
    </div>
    
    <div class="toast" id="toast">Données sauvegardées !</div>

<script>
    // ========================================================================
    // SCRIPT JS AVEC LES PROGRAMMES CORE INTÉGRÉS
    // ========================================================================

    // Workout data structure
    const workouts = {
        A: {
            push: [
                { name: "Développé couché barre", sets: 4, reps: "6-10" },
                { name: "Développé incliné haltères", sets: 3, reps: "8-12" },
                { name: "Écartés haltères plat", sets: 3, reps: "10-15" },
                { name: "Développé militaire haltères", sets: 4, reps: "6-10" },
                { name: "Élévations latérales haltères", sets: 3, reps: "12-15" },
                { name: "Dips", sets: 3, reps: "8-12" },
                { name: "Barre au front EZ", sets: 3, reps: "10-15" }
            ],
            leg: [
                { name: "Squat barre libre", sets: 4, reps: "8-12" },
                { name: "Fentes bulgares", sets: 3, reps: "10-12" },
                { name: "Walking lunges haltères", sets: 3, reps: "20 pas" },
                { name: "Single Leg RDL (haltère)", sets: 3, reps: "12-15/j" },
                { name: "RDL (Romanian Deadlift)", sets: 4, reps: "8-12" },
                { name: "Sliding Leg Curls (disques)", sets: 3, reps: "12-15" },
                { name: "Mollets debout barre", sets: 5, reps: "15-20" }
            ],
            pull: [
                { name: "Tractions", sets: 4, reps: "Max" },
                { name: "Rowing barre", sets: 4, reps: "6-10" },
                { name: "Rowing haltère unilatéral", sets: 3, reps: "8-12" },
                { name: "Shrugs haltères", sets: 3, reps: "10-12" },
                { name: "Oiseau haltères penché", sets: 3, reps: "15-20" },
                { name: "Curl barre EZ", sets: 4, reps: "8-12" },
                { name: "Curl marteau haltères", sets: 3, reps: "10-15" }
            ],
            lower: [
                { name: "RDL barre", sets: 4, reps: "8-12" },
                { name: "Front squat", sets: 4, reps: "8-12" },
                { name: "Fentes avant haltères", sets: 3, reps: "10-12" },
                { name: "Fentes arrière haltères", sets: 3, reps: "10-12/j" },
                { name: "SLDL (Soulevé jambes tendues)", sets: 3, reps: "12-15" },
                { name: "Mollets debout haltère unilatéral", sets: 5, reps: "15-20" }
            ],
            upper: [
                { name: "Développé couché haltères", sets: 4, reps: "8-12" },
                { name: "Rowing Pendlay", sets: 3, reps: "10-12" },
                { name: "Développé militaire haltères", sets: 4, reps: "8-12" },
                { name: "Tractions prise neutre", sets: 3, reps: "10-15" },
                { name: "Shrugs barre", sets: 3, reps: "12-15" },
                { name: "Dips", sets: 3, reps: "15-20" },
                { name: "Superset: Curl barre / Extension nuque", sets: 3, reps: "10-12" }
            ],
            // SESSIONS CORE AJOUTÉES
            core_a: [
                { name: "Roue Abdominale", sets: 3, reps: "8-12" },
                { name: "Relevés de Jambes Suspendus", sets: 3, reps: "10-15" },
                { name: "Planche", sets: 3, reps: "30-45s" }
            ],
            core_b: [
                { name: "Pallof Press", sets: 3, reps: "12-15/côté" },
                { name: "Crunch Poulie Haute", sets: 3, reps: "15-20" },
                { name: "Portés en Valise", sets: 3, reps: "20 pas/côté" }
            ]
        },
        B: {
            push: [
                { name: "Supine Press", sets: 4, reps: "6-10" },
                { name: "Développé incliné Smith", sets: 3, reps: "8-12" },
                { name: "Pec fly", sets: 3, reps: "10-15" },
                { name: "Développé militaire Smith", sets: 4, reps: "6-10" },
                { name: "Lateral raise machine", sets: 3, reps: "12-15" },
                { name: "Dips", sets: 3, reps: "8-12" },
                { name: "Extensions triceps poulie haute", sets: 3, reps: "10-15" }
            ],
            leg: [
                { name: "Hack squat", sets: 4, reps: "8-12" },
                { name: "Fentes bulgares", sets: 3, reps: "10-12" },
                { name: "Presse horizontale", sets: 3, reps: "15-20" },
                { name: "Leg extensions", sets: 3, reps: "12-15" },
                { name: "SLDL (Stiff Leg Deadlift)", sets: 4, reps: "8-12" },
                { name: "Leg curls assis", sets: 3, reps: "10-15" },
                { name: "Mollets presse", sets: 5, reps: "15-20" }
            ],
            pull: [
                { name: "Tractions", sets: 4, reps: "Max" },
                { name: "T-Bar Row", sets: 4, reps: "6-10" },
                { name: "Tirage vertical supination", sets: 3, reps: "8-12" },
                { name: "Rowing haltère unilatéral", sets: 3, reps: "10-12" },
                { name: "Reverse peck deck", sets: 3, reps: "15-20" },
                { name: "Machine arm curl", sets: 4, reps: "8-12" },
                { name: "Curl incliné haltères", sets: 3, reps: "10-15" }
            ],
            lower: [
                { name: "RDL", sets: 4, reps: "8-12" },
                { name: "Presse à cuisses", sets: 4, reps: "8-12" },
                { name: "Fentes avant haltères", sets: 3, reps: "10-12" },
                { name: "Leg curls allongé", sets: 4, reps: "10-15" },
                {
    name: "Superset Abducteurs", 
    isSuperset: true,
    exercises: [
        { name: "Abductions", sets: 3, reps: "15-20" },
        { name: "Adductions", sets: 3, reps: "15-20" }
    ]
},
                { name: "Extensions lombaires", sets: 3, reps: "12-15" },
                { name: "Mollets machine", sets: 5, reps: "15-20" }
            ],
            upper: [
                { name: "Développé couché haltères", sets: 4, reps: "8-12" },
                { name: "Landmine Press", sets: 3, reps: "10-12" },
                { name: "Tirage horizontal poulie", sets: 4, reps: "8-12" },
                { name: "Machine convergente", sets: 3, reps: "10-15" },
                { name: "Shrugs machine", sets: 3, reps: "12-15" },
                { name: "Élévations latérales machine", sets: 3, reps: "15-20" },
                { 
    name: "Superset Bras", 
    isSuperset: true,
    exercises: [
        { name: "Machine curl", sets: 3, reps: "10-12" },
        { name: "Extensions poulie", sets: 3, reps: "10-12" }
    ]
}
            ],
            // SESSIONS CORE AJOUTÉES (aussi au programme B)
            core_a: [
                { name: "Roue Abdominale", sets: 3, reps: "8-12" },
                { name: "Relevés de Jambes Suspendus", sets: 3, reps: "10-15" },
                { name: "Planche", sets: 3, reps: "30-45s" }
            ],
            core_b: [
                { name: "Pallof Press", sets: 3, reps: "12-15/côté" },
                { name: "Crunch Poulie Haute", sets: 3, reps: "15-20" },
                { name: "Portés en Valise", sets: 3, reps: "20 pas/côté" }
            ]
        }
    };
    
    // Mapping des exercices par catégories musculaires
   const exerciseCategories = {
    'Pectoraux': [
        'Développé couché barre',
        'Développé incliné haltères',
        'Écarté incliné',
        'Développé décliné barre',
        'Pec fly poulie',
        'Supine Press',
        'Développé incliné Smith',
        'Pec fly',
        'Développé couché haltères',
        'Écartés haltères plat'
    ],
    'Dos': [
        'Tirage horizontal machine',
        'Rowing barre pronation',
        'Rowing barre',
        'Rowing Pendlay',
        'Shrugs barre',
        'Shrugs haltères',
        'Pull-over machine',
        'Tractions',
        'T-Bar Row',
        'Tirage vertical supination',
        'Rowing haltère unilatéral',
        'Tirage horizontal poulie',
        'Machine convergente',
        'Shrugs machine'
    ],
    'Épaules': [
        'Développé militaire barre',
        'Développé militaire haltères',
        'Oiseau haltères banc incliné',
        'Oiseau haltères penché',
        'Face pull poulie',
        'Lateral raise haltères',
        'Élévations latérales haltères',
        'Développé militaire Smith',
        'Lateral raise machine',
        'Reverse peck deck',
        'Landmine Press',
        'Élévations latérales machine'
    ],
    'Bras (Triceps)': [
        'Dips',
        'Extensions triceps poulie',
        'Extensions triceps poulie haute',
        'Barre au front EZ',
        'Superset: Machine curl / Extensions poulie',
        'Extensions poulie'
    ],
    'Bras (Biceps)': [
        'Curl barre EZ',
        'Curl haltères alterné',
        'Curl marteau haltères',
        'Machine arm curl',
        'Curl incliné haltères',
        'Machine curl'
    ],
    'Quadriceps': [
        'Squat barre libre',
        'Front squat',
        'Leg extensions',
        'Fentes bulgares',
        'Fentes arrière haltères',
        'Walking lunges haltères',
        'Hack squat',
        'Presse horizontale',
        'Presse à cuisses',
        'Fentes avant haltères'
    ],
    'Ischio-jambiers': [
        'Leg curls allongé',
        'RDL (Romanian Deadlift)',
        'RDL',
        'RDL barre',
        'SLDL (Stiff Leg Deadlift)',
        'SLDL (Soulevé jambes tendues)',
        'Single Leg RDL (haltère)',
        'Leg curls assis'
    ],
    'Fessiers/Adducteurs': [
        'Hip thrust',
        'Superset: Abductions + Adductions',
        'Abductions',
        'Adductions'
    ],
    'Mollets': [
        'Mollets à la Smith machine',
        'Mollets debout barre',
        'Mollets presse',
        'Mollets machine'
    ],
    'Lombaires': [
        'Extensions lombaires'
    ],
    'Abdominaux': [
        'Roue Abdominale',
        'Relevés de Jambes Suspendus',
        'Planche',
        'Pallof Press',
        'Crunch Poulie Haute',
        'Portés en Valise'
    ]
}; 
    // Fonction pour trouver la catégorie d'un exercice
    function getExerciseCategory(exerciseName) {
        for (const [category, exercises] of Object.entries(exerciseCategories)) {
            if (exercises.includes(exerciseName)) {
                return category;
            }
        }
        return 'Autres'; // Si l'exercice n'est pas trouvé
    }
    
    // Global variables
    let currentProgram = 'A';
    let currentWorkout = null;
    let workoutData = {};
    // ==================== CONFIGURATION API SYNC ====================
    const API_CONFIG = {
        baseUrl: window.location.origin,
        apiKey: 'freddebian79claudius', // CHANGE CE MOT DE PASSE !
        autoSync: true,
        syncDelay: 1000 // ms après la dernière modification
    };
    
    let syncTimeout = null;
    let isSyncing = false;
    
    // ==================== API SYNCHRONIZATION FUNCTIONS ====================
    async function syncToServer(data) {
        if (isSyncing) return;
        
        isSyncing = true;
        updateSyncStatus('syncing', 'Synchronisation...');
        
        try {
            const response = await fetch(`${API_CONFIG.baseUrl}/api.php?action=save`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${API_CONFIG.apiKey}`
                },
                body: JSON.stringify(data)
            });
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
            }
            
            const result = await response.json();
            updateSyncStatus('synced', 'Synchronisé');
            return true;
        } catch (error) {
            console.error('Erreur de synchronisation:', error);
            updateSyncStatus('error', 'Erreur sync');
            showToast('❌ Erreur de synchronisation');
            return false;
        } finally {
            isSyncing = false;
        }
    }
    
    async function loadFromServer() {
        updateSyncStatus('syncing', 'Chargement...');
        
        try {
            const response = await fetch(`${API_CONFIG.baseUrl}/api.php?action=load`, {
                method: 'GET',
                headers: {
                    'Authorization': `Bearer ${API_CONFIG.apiKey}`
                }
            });
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
            }
            
            const data = await response.json();
            workoutData = data;
            localStorage.setItem('workoutData', JSON.stringify(workoutData));
            updateSyncStatus('synced', 'Synchronisé');
            return true;
        } catch (error) {
            console.error('Erreur de chargement:', error);
            updateSyncStatus('error', 'Erreur chargement');
            
            // Fallback sur localStorage
            const stored = localStorage.getItem('workoutData');
            if (stored) {
                workoutData = JSON.parse(stored);
                showToast('📱 Mode hors ligne');
            }
            return false;
        }
    }
    
    function updateSyncStatus(status, text) {
        const indicator = document.getElementById('syncIndicator');
        const statusText = document.getElementById('syncText');
        
        if (indicator && statusText) {
            indicator.className = 'sync-indicator';
            if (status === 'syncing') {
                indicator.classList.add('syncing');
            } else if (status === 'error') {
                indicator.classList.add('error');
            }
            
            statusText.textContent = text;
        }
    }
    
    async function syncNow() {
        await loadFromServer();
        if (currentWorkout && currentWorkout !== 'stats') {
            loadData();
        }
        processAllData();
        showToast('🔄 Données rechargées !');
    }

    let charts = {};
    let goals = [];
    let currentView = 'week';
    
    // NOUVELLE VARIABLE GLOBALE POUR LES PERFORMANCES
    let processedData = []; // Stocke les données "aplaties" pour des calculs rapides

    // Initialize on page load
    document.addEventListener('DOMContentLoaded', async function() {
        const today = new Date().toISOString().split('T')[0];
        document.getElementById('dateSelector').value = today;
        await loadFromServer();
        loadAllData();
        calculateStreak();
        initializeGoals();
    });
    
    // Program selection
    function setProgram(program) {
        currentProgram = program;
        document.querySelectorAll('.toggle-btn').forEach(btn => {
            btn.classList.remove('active');
        });
        event.target.classList.add('active');
        if (currentWorkout && currentWorkout !== 'stats') {
            selectWorkout(currentWorkout);
        }
    }
    
    // Workout selection
    function selectWorkout(type) {
        currentWorkout = type;
        
        // Update UI visibility
        document.getElementById('statsDashboard').classList.remove('active');
        document.getElementById('workoutTable').classList.add('active');
        document.getElementById('stats').style.display = 'grid';
        document.getElementById('workoutControls').style.display = 'flex';
        document.getElementById('exportBtn').style.display = 'none';
        
        // Update button styles
        document.querySelectorAll('.workout-btn').forEach(btn => {
            // LIGNE MODIFIÉE : Ajout des nouvelles classes core
            btn.classList.remove('active-push', 'active-leg', 'active-pull', 
                               'active-lower', 'active-upper', 'active-stats',
                               'active-core_a', 'active-core_b');
        });
        event.target.classList.add(`active-${type}`);
        
        // Generate workout table
        generateTable(type);
        loadData();
    }
    
    // Show statistics dashboard
    function showStats() {
        currentWorkout = 'stats';
        
        // Update UI visibility
        document.getElementById('workoutTable').classList.remove('active');
        document.getElementById('stats').style.display = 'none';
        document.getElementById('statsDashboard').classList.add('active');
        document.getElementById('workoutControls').style.display = 'none';
        document.getElementById('exportBtn').style.display = 'flex';
        
        // Update button styles
        document.querySelectorAll('.workout-btn').forEach(btn => {
            // LIGNE MODIFIÉE : Ajout des nouvelles classes core
            btn.classList.remove('active-push', 'active-leg', 'active-pull', 
                               'active-lower', 'active-upper', 'active-stats',
                               'active-core_a', 'active-core_b');
        });
        event.target.classList.add('active-stats');
        
        // Génère les stats du premier onglet
        calculateWeeklyStats();
        generateVolumeChart();
        generateMuscleChart();
        generateProgramChart();
        generateCalendar();
    }
    
    // Generate workout table
    function generateTable(type) {
    const exercises = workouts[currentProgram][type];
    if (!exercises) return;
    
    let html = '<table><thead><tr><th>Exercice</th><th>Séries</th><th>Reps cible</th>';
    
    // Calculer le nombre max de séries en tenant compte des supersets
    const maxSets = Math.max(0, ...exercises.map(e => {
        if (e.isSuperset) {
            return Math.max(...e.exercises.map(ex => ex.sets));
        }
        return e.sets;
    }));
    
    for (let i = 1; i <= maxSets; i++) {
        html += `<th>S${i}</th>`;
    }
    html += '<th>Poids (kg)</th><th>Notes</th></tr></thead><tbody>';
    
    let rowIndex = 0; // Index global pour les IDs des inputs
    
    exercises.forEach((exercise, idx) => {
        if (exercise.isSuperset) {
            // Ligne d'en-tête du superset
            html += `<tr style="background: linear-gradient(135deg, rgba(102, 126, 234, 0.1) 0%, rgba(118, 75, 162, 0.1) 100%);">
                <td class="exercise-name" style="font-weight: 700; color: #667eea;">${exercise.name}</td>
                <td colspan="${maxSets + 3}"></td>
            </tr>`;
            
            // Lignes pour chaque exercice du superset
            exercise.exercises.forEach((subExercise, subIdx) => {
                html += `<tr>
                    <td class="exercise-name" style="padding-left: 30px;">├─ ${subExercise.name}</td>
                    <td>${subExercise.sets}</td>
                    <td>${subExercise.reps}</td>`;
                
                for (let i = 0; i < maxSets; i++) {
                    if (i < subExercise.sets) {
                        html += `<td>
                            <input type="number" id="reps-${rowIndex}-${i}" 
                                   min="0" max="50" onchange="autoSave()" 
                                   placeholder="0">
                        </td>`;
                    } else {
                        html += '<td>-</td>';
                    }
                }
                
                html += `<td>
                    <input type="number" class="weight-input" id="weight-${rowIndex}" 
                           min="0" max="500" step="0.5" onchange="autoSave()" 
                           placeholder="0">
                </td>
                <td>
                    <input type="text" id="notes-${rowIndex}" 
                           onchange="autoSave()" placeholder="..." 
                           style="width: 100px;">
                </td>
                </tr>`;
                
                rowIndex++;
            });
        } else {
            // Exercice normal
            html += `<tr>
                <td class="exercise-name">${exercise.name}</td>
                <td>${exercise.sets}</td>
                <td>${exercise.reps}</td>`;
            
            for (let i = 0; i < maxSets; i++) {
                if (i < exercise.sets) {
                    html += `<td>
                        <input type="number" id="reps-${rowIndex}-${i}" 
                               min="0" max="50" onchange="autoSave()" 
                               placeholder="0">
                    </td>`;
                } else {
                    html += '<td>-</td>';
                }
            }
            
            html += `<td>
                <input type="number" class="weight-input" id="weight-${rowIndex}" 
                       min="0" max="500" step="0.5" onchange="autoSave()" 
                       placeholder="0">
            </td>
            <td>
                <input type="text" id="notes-${rowIndex}" 
                       onchange="autoSave()" placeholder="..." 
                       style="width: 100px;">
            </td>
            </tr>`;
            
            rowIndex++;
        }
    });
    
    html += '</tbody></table>';
    document.getElementById('workoutTable').innerHTML = html;
}
    
    // Data management
    function getDataKey() {
        const date = document.getElementById('dateSelector').value;
        return `workout-${date}-${currentProgram}-${currentWorkout}`;
    }
    
    function autoSave() {
        saveData();
        updateStats();
    }
    
    function saveData() {
    if (!currentWorkout || currentWorkout === 'stats') return;
    
    const key = getDataKey();
    const data = {};
    const exercises = workouts[currentProgram][currentWorkout];
    
    let rowIndex = 0; // Index global pour correspondre aux IDs des inputs
    
    exercises.forEach((exercise, idx) => {
        if (exercise.isSuperset) {
            // Sauvegarder chaque exercice du superset
            data[idx] = {
                isSuperset: true,
                exercises: []
            };
            
            exercise.exercises.forEach((subExercise) => {
                const reps = [];
                for (let i = 0; i < subExercise.sets; i++) {
                    const input = document.getElementById(`reps-${rowIndex}-${i}`);
                    if (input) reps.push(input.value || '');
                }
                
                const weightInput = document.getElementById(`weight-${rowIndex}`);
                const notesInput = document.getElementById(`notes-${rowIndex}`);
                
                data[idx].exercises.push({
                    name: subExercise.name,
                    reps: reps,
                    weight: weightInput ? weightInput.value : '',
                    notes: notesInput ? notesInput.value : ''
                });
                
                rowIndex++;
            });
        } else {
            // Exercice normal
            const reps = [];
            for (let i = 0; i < exercise.sets; i++) {
                const input = document.getElementById(`reps-${rowIndex}-${i}`);
                if (input) reps.push(input.value || '');
            }
            
            const weightInput = document.getElementById(`weight-${rowIndex}`);
            const notesInput = document.getElementById(`notes-${rowIndex}`);
            
            data[idx] = {
                reps: reps,
                weight: weightInput ? weightInput.value : '',
                notes: notesInput ? notesInput.value : ''
            };
            
            rowIndex++;
        }
    });
    
    workoutData[key] = data;
    localStorage.setItem('workoutData', JSON.stringify(workoutData));
    
    // Regénère les données pré-calculées après sauvegarde
    processAllData(); 
    
    calculateStreak();
    checkForPRs(key, data);
    showToast('Données sauvegardées !');
    
    // Auto-sync avec délai
    if (API_CONFIG.autoSync) {
        clearTimeout(syncTimeout);
        syncTimeout = setTimeout(async () => {
            await syncToServer(workoutData);
        }, API_CONFIG.syncDelay);
    }
}
    
    function loadData() {
    if (!currentWorkout || currentWorkout === 'stats') return;
    
    const key = getDataKey();
    const data = workoutData[key] || {};
    const exercises = workouts[currentProgram][currentWorkout];
    
    let rowIndex = 0; // Index global pour correspondre aux IDs des inputs
    
    exercises.forEach((exercise, idx) => {
        const exerciseData = data[idx] || {};
        
        if (exercise.isSuperset && exerciseData.isSuperset) {
            // Charger chaque exercice du superset
            if (exerciseData.exercises) {
                exerciseData.exercises.forEach((subExerciseData, subIdx) => {
                    // Load reps
                    if (subExerciseData.reps) {
                        subExerciseData.reps.forEach((rep, i) => {
                            const input = document.getElementById(`reps-${rowIndex}-${i}`);
                            if (input) input.value = rep;
                        });
                    }
                    
                    // Load weight
                    const weightInput = document.getElementById(`weight-${rowIndex}`);
                    if (weightInput && subExerciseData.weight) {
                        weightInput.value = subExerciseData.weight;
                    }
                    
                    // Load notes
                    const notesInput = document.getElementById(`notes-${rowIndex}`);
                    if (notesInput && subExerciseData.notes) {
                        notesInput.value = subExerciseData.notes;
                    }
                    
                    rowIndex++;
                });
            }
        } else {
            // Exercice normal
            // Load reps
            if (exerciseData.reps) {
                exerciseData.reps.forEach((rep, i) => {
                    const input = document.getElementById(`reps-${rowIndex}-${i}`);
                    if (input) input.value = rep;
                });
            }
            
            // Load weight
            const weightInput = document.getElementById(`weight-${rowIndex}`);
            if (weightInput && exerciseData.weight) {
                weightInput.value = exerciseData.weight;
            }
            
            // Load notes
            const notesInput = document.getElementById(`notes-${rowIndex}`);
            if (notesInput && exerciseData.notes) {
                notesInput.value = exerciseData.notes;
            }
            
            rowIndex++;
        }
    });
    
    updateStats();
}
    
    function loadAllData() {
        const stored = localStorage.getItem('workoutData');
        if (stored) {
            workoutData = JSON.parse(stored);
        }
        
        const storedGoals = localStorage.getItem('workoutGoals');
        if (storedGoals) {
            goals = JSON.parse(storedGoals);
        }
        
        // Pré-calcule toutes les données pour les stats
        processAllData();
        
        // Mettre à jour les stats Phase 3
        if (typeof updatePhase3Stats === 'function') {
            updatePhase3Stats();
        }
    }
    
    function processAllData() {
        processedData = []; // Vider les anciennes données
        Object.keys(workoutData).forEach(key => {
            try {
                const [, dateStr, monthStr, dayStr, program, workoutType] = key.split('-');
                const date = new Date(`${dateStr}-${monthStr}-${dayStr}`);
                
                if (!workouts[program] || !workouts[program][workoutType]) {
                    return; 
                }
                
                const exercises = workouts[program][workoutType];
                const sessionData = workoutData[key];
                
				Object.keys(sessionData).forEach(exerciseIndex => {
    const exerciseInfo = sessionData[exerciseIndex];
    const exerciseTemplate = exercises[exerciseIndex];
    
    if (exerciseTemplate) {
        if (exerciseInfo.isSuperset && exerciseTemplate.isSuperset) {
            // Traiter chaque exercice du superset
            if (exerciseInfo.exercises) {
                exerciseInfo.exercises.forEach((subExerciseData) => {
                    const exerciseName = subExerciseData.name;
                    const weight = parseFloat(subExerciseData.weight || 0);
                    
                    if (subExerciseData.reps) {
                        subExerciseData.reps.forEach((rep, setIndex) => {
                            const reps = parseInt(rep || 0);
                            if (reps > 0) {
                                processedData.push({
                                    date: date,
                                    dateKey: `${dateStr}-${monthStr}-${dayStr}`,
                                    program: program,
                                    workoutType: workoutType,
                                    exerciseName: exerciseName,
                                    set: setIndex + 1,
                                    reps: reps,
                                    weight: weight,
                                    volume: reps * weight
                                });
                            }
                        });
                    }
                });
            }
        } else {
            // Exercice normal
            const exerciseName = exerciseTemplate.name;
            const weight = parseFloat(exerciseInfo.weight || 0);
            
            if (exerciseInfo.reps) {
                exerciseInfo.reps.forEach((rep, setIndex) => {
                    const reps = parseInt(rep || 0);
                    if (reps > 0) {
                        processedData.push({
                            date: date,
                            dateKey: `${dateStr}-${monthStr}-${dayStr}`,
                            program: program,
                            workoutType: workoutType,
                            exerciseName: exerciseName,
                            set: setIndex + 1,
                            reps: reps,
                            weight: weight,
                            volume: reps * weight
                        });
                    }
                });
            }
        }
    }
});
            } catch (e) {
                console.error(`Erreur lors du traitement de la clé: ${key}`, e);
            }
        });
    }

    // Statistics update
    function updateStats() {
    if (!currentWorkout || currentWorkout === 'stats') return;
    
    let totalVolume = 0;
    let totalSets = 0;
    let totalReps = 0;
    let maxIntensity = 0;
    
    const exercises = workouts[currentProgram][currentWorkout];
    let rowIndex = 0; // Index global pour correspondre aux IDs des inputs
    
    exercises.forEach((exercise, idx) => {
        if (exercise.isSuperset) {
            // Traiter chaque exercice du superset
            exercise.exercises.forEach((subExercise) => {
                const weightInput = document.getElementById(`weight-${rowIndex}`);
                const weight = parseFloat(weightInput?.value || 0);
                
                for (let i = 0; i < subExercise.sets; i++) {
                    const repsInput = document.getElementById(`reps-${rowIndex}-${i}`);
                    const reps = parseInt(repsInput?.value || 0);
                    
                    if (reps > 0) {
                        totalSets++;
                        totalReps += reps;
                        totalVolume += reps * weight;
                        
                        if (weight > 0) {
                            const intensity = weight / (1.0278 - 0.0278 * reps);
                            maxIntensity = Math.max(maxIntensity, intensity);
                        }
                    }
                }
                rowIndex++;
            });
        } else {
            // Exercice normal
            const weightInput = document.getElementById(`weight-${rowIndex}`);
            const weight = parseFloat(weightInput?.value || 0);
            
            for (let i = 0; i < exercise.sets; i++) {
                const repsInput = document.getElementById(`reps-${rowIndex}-${i}`);
                const reps = parseInt(repsInput?.value || 0);
                
                if (reps > 0) {
                    totalSets++;
                    totalReps += reps;
                    totalVolume += reps * weight;
                    
                    if (weight > 0) {
                        const intensity = weight / (1.0278 - 0.0278 * reps);
                        maxIntensity = Math.max(maxIntensity, intensity);
                    }
                }
            }
            rowIndex++;
        }
    });
    
    document.getElementById('totalVolume').textContent = totalVolume.toFixed(0) + ' kg';
    document.getElementById('totalSets').textContent = totalSets;
    document.getElementById('totalReps').textContent = totalReps;
    
    if (maxIntensity > 0) {
        const bodyWeight = 90; // Default body weight
        const relativeIntensity = (maxIntensity / bodyWeight * 100).toFixed(0);
        document.getElementById('avgRest').textContent = relativeIntensity + '%';
    } else {
        document.getElementById('avgRest').textContent = '-';
    }
}

// ========================================================================
// NOUVELLES FONCTIONS POUR LES CYCLES - PHASE 1 MVP
// ========================================================================

/**
 * Retourne le début de la semaine (lundi) pour une date donnée
 */
function getWeekStart(date) {
    const d = new Date(date);
    const day = d.getDay();
    const diff = d.getDate() - day + (day === 0 ? -6 : 1);
    return new Date(d.setDate(diff));
}

/**
 * Détecte les cycles de 3 semaines dans les données
 */
function detectCycles(program) {
    const programData = processedData.filter(item => item.program === program);
    
    if (programData.length === 0) return [];
    
    const sortedData = programData.sort((a, b) => a.date - b.date);
    
    const weeklyData = {};
    sortedData.forEach(item => {
        const weekStart = getWeekStart(item.date);
        const weekKey = weekStart.toISOString().split('T')[0];
        
        if (!weeklyData[weekKey]) {
            weeklyData[weekKey] = {
                weekStart: weekStart,
                volume: 0,
                sessions: new Set(),
                data: []
            };
        }
        
        weeklyData[weekKey].volume += item.volume;
        weeklyData[weekKey].sessions.add(item.dateKey);
        weeklyData[weekKey].data.push(item);
    });
    
    const weeks = Object.values(weeklyData).sort((a, b) => a.weekStart - b.weekStart);
    
    const cycles = [];
    for (let i = 0; i < weeks.length; i += 3) {
        const cycleWeeks = weeks.slice(i, i + 3);
        if (cycleWeeks.length > 0) {
            cycles.push({
                cycleNumber: Math.floor(i / 3) + 1,
                weeks: cycleWeeks,
                startDate: cycleWeeks[0].weekStart,
                endDate: cycleWeeks[cycleWeeks.length - 1] ? 
                    new Date(cycleWeeks[cycleWeeks.length - 1].weekStart.getTime() + 6 * 24 * 60 * 60 * 1000) : 
                    new Date(),
                totalVolume: cycleWeeks.reduce((sum, w) => sum + w.volume, 0),
                completed: cycleWeeks.length === 3
            });
        }
    }
    
    return cycles;
}

/**
 * Retourne le cycle actuel pour un programme donné
 */
function getCurrentCycle(program) {
    const cycles = detectCycles(program);
    if (cycles.length === 0) return null;
    
    const now = new Date();
    
    for (const cycle of cycles.reverse()) {
        if (cycle.startDate <= now && cycle.endDate >= now) {
            return cycle;
        }
    }
    
    return cycles[cycles.length - 1];
}

/**
 * Affiche la carte du cycle actuel
 */
function displayCycleCard(program, containerId) {
    const container = document.getElementById(containerId);
    if (!container) return;
    
    const cycle = getCurrentCycle(program);
    
    if (!cycle) {
        container.innerHTML = `
            <div class="cycle-card">
                <div class="cycle-header">
                    <div class="cycle-title">Aucun cycle détecté</div>
                </div>
                <p style="text-align: center; color: #666;">
                    Commence à t'entraîner pour voir apparaître tes cycles !
                </p>
            </div>
        `;
        return;
    }
    
    const now = new Date();
    const weeklyAverage = cycle.totalVolume / cycle.weeks.length;
    
    let weeksHTML = '';
    cycle.weeks.forEach((week, index) => {
        const isCurrentWeek = week.weekStart <= now && 
            new Date(week.weekStart.getTime() + 6 * 24 * 60 * 60 * 1000) >= now;
        
        const prevWeekVolume = index > 0 ? cycle.weeks[index - 1].volume : null;
        let progressHTML = '';
        if (prevWeekVolume && week.volume > 0) {
            const change = ((week.volume - prevWeekVolume) / prevWeekVolume * 100).toFixed(1);
            const sign = change >= 0 ? '+' : '';
            const colorClass = change >= 0 ? 'positive' : 'negative';
            progressHTML = `<span class="metric-change ${colorClass}">${sign}${change}%</span>`;
        }
        
        weeksHTML += `
            <div class="week-card ${isCurrentWeek ? 'current' : ''}">
                <div class="week-number">Semaine ${index + 1}</div>
                <div class="week-volume">${week.volume.toFixed(0)} kg</div>
                <div class="week-progress">${progressHTML}</div>
                ${isCurrentWeek ? '<div style="margin-top: 10px; color: #4CAF50; font-weight: 600;">📍 En cours</div>' : ''}
            </div>
        `;
    });
    
    while (cycle.weeks.length < 3) {
        weeksHTML += `
            <div class="week-card">
                <div class="week-number">Semaine ${cycle.weeks.length + 1}</div>
                <div class="week-volume" style="color: #ccc;">À venir</div>
            </div>
        `;
        cycle.weeks.push(null);
    }
    
    container.innerHTML = `
        <div class="cycle-card">
            <div class="cycle-header">
                <div class="cycle-title">Cycle #${cycle.cycleNumber} - Programme ${program}</div>
                <div style="color: #666;">
                    ${cycle.startDate.toLocaleDateString('fr-FR', { day: '2-digit', month: 'short' })} - 
                    ${cycle.endDate.toLocaleDateString('fr-FR', { day: '2-digit', month: 'short', year: 'numeric' })}
                </div>
            </div>
            
            <div class="cycle-weeks">
                ${weeksHTML}
            </div>
            
            <div style="margin-top: 20px; padding: 15px; background: white; border-radius: 10px; text-align: center;">
                <div style="font-size: 0.9em; color: #999; margin-bottom: 5px;">Volume total du cycle</div>
                <div style="font-size: 2em; font-weight: bold; color: #2196F3;">${cycle.totalVolume.toFixed(0)} kg</div>
                <div style="font-size: 0.9em; color: #666; margin-top: 5px;">
                    Moyenne : ${weeklyAverage.toFixed(0)} kg/semaine
                </div>
            </div>
        </div>
    `;
}

/**
 * Affiche la comparaison inter-cycles
 */
function displayCycleComparison(program, containerId) {
    const container = document.getElementById(containerId);
    if (!container) return;
    
    const cycles = detectCycles(program);
    
    if (cycles.length < 2) {
        container.innerHTML = `
            <p style="text-align: center; color: #666; padding: 20px;">
                Pas encore assez de cycles pour comparer. Continue à t'entraîner !
            </p>
        `;
        return;
    }
    
    const currentCycle = cycles[cycles.length - 1];
    const previousCycle = cycles[cycles.length - 2];
    
    let comparisonHTML = '';
    
    for (let weekIndex = 0; weekIndex < 3; weekIndex++) {
        const currentWeek = currentCycle.weeks[weekIndex];
        const previousWeek = previousCycle.weeks[weekIndex];
        
        if (!currentWeek && !previousWeek) continue;
        
        const currentVolume = currentWeek ? currentWeek.volume : 0;
        const previousVolume = previousWeek ? previousWeek.volume : 0;
        
        let change = 0;
        let changeHTML = '';
        let arrowHTML = '→';
        
        if (previousVolume > 0 && currentVolume > 0) {
            change = ((currentVolume - previousVolume) / previousVolume * 100).toFixed(1);
            const sign = change >= 0 ? '+' : '';
            const colorClass = change >= 0 ? 'positive' : 'negative';
            changeHTML = `<span class="metric-change ${colorClass}">${sign}${change}%</span>`;
            arrowHTML = change >= 0 ? '📈' : '📉';
        }
        
        comparisonHTML += `
            <div class="comparison-card">
                <div class="comparison-title">Semaine ${weekIndex + 1}</div>
                <div class="comparison-values">
                    <div class="comparison-value">
                        <div class="comparison-label">Cycle ${previousCycle.cycleNumber}</div>
                        <div class="comparison-number">${previousVolume.toFixed(0)}</div>
                        <div class="comparison-label">kg</div>
                    </div>
                    <div class="comparison-arrow">${arrowHTML}</div>
                    <div class="comparison-value">
                        <div class="comparison-label">Cycle ${currentCycle.cycleNumber}</div>
                        <div class="comparison-number">${currentVolume.toFixed(0)}</div>
                        <div class="comparison-label">kg</div>
                    </div>
                </div>
                ${changeHTML}
            </div>
        `;
    }
    
    container.innerHTML = comparisonHTML;
}

/**
 * Graphique du volume par muscle pour un programme
 */
function generateMuscleChartByProgram(program, canvasId) {
    const ctx = document.getElementById(canvasId);
    if (!ctx) return;
    
    if (charts[canvasId]) charts[canvasId].destroy();
    
    const muscleGroups = { 'Pectoraux': 0, 'Dos': 0, 'Épaules': 0, 'Jambes': 0, 'Bras': 0, 'Abdos': 0 };
    
    const programData = processedData.filter(item => item.program === program);
    
    for (const item of programData) {
        const volume = item.volume;
        const workoutType = item.workoutType;
        
        if (workoutType === 'push') {
            muscleGroups['Pectoraux'] += volume * 0.5;
            muscleGroups['Épaules'] += volume * 0.3;
            muscleGroups['Bras'] += volume * 0.2;
        } else if (workoutType === 'pull') {
            muscleGroups['Dos'] += volume * 0.7;
            muscleGroups['Bras'] += volume * 0.3;
        } else if (workoutType === 'leg' || workoutType === 'lower') {
            muscleGroups['Jambes'] += volume;
        } else if (workoutType === 'upper') {
            muscleGroups['Pectoraux'] += volume * 0.3;
            muscleGroups['Dos'] += volume * 0.3;
            muscleGroups['Épaules'] += volume * 0.2;
            muscleGroups['Bras'] += volume * 0.2;
        } else if (workoutType === 'core_a' || workoutType === 'core_b') {
            muscleGroups['Abdos'] += volume;
        }
    }
    
    charts[canvasId] = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: Object.keys(muscleGroups),
            datasets: [{
                label: 'Volume Total (kg)',
                data: Object.values(muscleGroups),
                backgroundColor: [
                    'rgba(255, 99, 132, 0.8)',
                    'rgba(54, 162, 235, 0.8)',
                    'rgba(255, 206, 86, 0.8)',
                    'rgba(75, 192, 192, 0.8)',
                    'rgba(153, 102, 255, 0.8)',
                    'rgba(255, 159, 64, 0.8)'
                ]
            }]
        },
        options: {
            responsive: true,
            plugins: { legend: { display: false } },
            scales: { y: { beginAtZero: true } }
        }
    });
}

/**
 * Graphique de progression long terme par programme
 */
function generateProgressionChartByProgram(program, canvasId) {
    const ctx = document.getElementById(canvasId);
    if (!ctx) return;
    
    if (charts[canvasId]) charts[canvasId].destroy();
    
    const cycles = detectCycles(program);
    
    if (cycles.length === 0) return;
    
    const labels = cycles.map(c => `Cycle ${c.cycleNumber}`);
    const data = cycles.map(c => c.totalVolume);
    
    charts[canvasId] = new Chart(ctx, {
        type: 'line',
        data: {
            labels: labels,
            datasets: [{
                label: `Programme ${program}`,
                data: data,
                borderColor: program === 'A' ? 'rgb(102, 126, 234)' : 'rgb(118, 75, 162)',
                backgroundColor: program === 'A' ? 'rgba(102, 126, 234, 0.1)' : 'rgba(118, 75, 162, 0.1)',
                tension: 0.3,
                fill: true
            }]
        },
        options: {
            responsive: true,
            plugins: { legend: { display: false } },
            scales: { y: { beginAtZero: true } }
        }
    });
}

/**
 * Génère les métriques de comparaison A vs B
 */
function generateComparisonMetrics() {
    const dataA = processedData.filter(item => item.program === 'A');
    const dataB = processedData.filter(item => item.program === 'B');
    
    const volumeA = dataA.reduce((sum, item) => sum + item.volume, 0);
    const volumeB = dataB.reduce((sum, item) => sum + item.volume, 0);
    
    const sessionsA = new Set(dataA.map(item => item.dateKey)).size;
    const sessionsB = new Set(dataB.map(item => item.dateKey)).size;
    
    const ratio = volumeA > 0 ? (volumeB / volumeA).toFixed(2) : 0;
    
    document.getElementById('totalVolumeProgramA').textContent = volumeA.toFixed(0) + ' kg';
    document.getElementById('totalVolumeProgramB').textContent = volumeB.toFixed(0) + ' kg';
    document.getElementById('ratioBA').textContent = ratio + 'x';
    document.getElementById('totalSessionsComparison').textContent = sessionsA + sessionsB;
    document.getElementById('sessionsSplit').textContent = `A: ${sessionsA} | B: ${sessionsB}`;
}

/**
 * Graphique d'évolution comparative A vs B
 */
function generateComparisonEvolutionChart() {
    const ctx = document.getElementById('comparisonEvolutionChart');
    if (!ctx) return;
    
    if (charts.comparisonEvolution) charts.comparisonEvolution.destroy();
    
    const cyclesA = detectCycles('A');
    const cyclesB = detectCycles('B');
    
    const maxCycles = Math.max(cyclesA.length, cyclesB.length);
    const labels = [];
    const dataA = [];
    const dataB = [];
    
    for (let i = 0; i < maxCycles; i++) {
        labels.push(`Cycle ${i + 1}`);
        dataA.push(cyclesA[i] ? cyclesA[i].totalVolume : 0);
        dataB.push(cyclesB[i] ? cyclesB[i].totalVolume : 0);
    }
    
    charts.comparisonEvolution = new Chart(ctx, {
        type: 'line',
        data: {
            labels: labels,
            datasets: [{
                label: 'Programme A (Libre)',
                data: dataA,
                borderColor: 'rgb(102, 126, 234)',
                tension: 0.3
            }, {
                label: 'Programme B (Guidé)',
                data: dataB,
                borderColor: 'rgb(118, 75, 162)',
                tension: 0.3
            }]
        },
        options: {
            responsive: true,
            plugins: { legend: { position: 'top' } },
            scales: { y: { beginAtZero: true } }
        }
    });
}

/**
 * Graphique comparatif par type de séance
 */
function generateWorkoutTypeComparisonChart() {
    const ctx = document.getElementById('workoutTypeComparisonChart');
    if (!ctx) return;
    
    if (charts.workoutTypeComparison) charts.workoutTypeComparison.destroy();
    
    const workoutTypes = ['push', 'pull', 'leg', 'upper', 'lower', 'core_a', 'core_b'];
    const volumesA = {};
    const volumesB = {};
    
    workoutTypes.forEach(type => {
        volumesA[type] = processedData
            .filter(item => item.program === 'A' && item.workoutType === type)
            .reduce((sum, item) => sum + item.volume, 0);
        
        volumesB[type] = processedData
            .filter(item => item.program === 'B' && item.workoutType === type)
            .reduce((sum, item) => sum + item.volume, 0);
    });
    
    charts.workoutTypeComparison = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: workoutTypes.map(t => t.toUpperCase()),
            datasets: [{
                label: 'Programme A',
                data: Object.values(volumesA),
                backgroundColor: 'rgba(102, 126, 234, 0.8)'
            }, {
                label: 'Programme B',
                data: Object.values(volumesB),
                backgroundColor: 'rgba(118, 75, 162, 0.8)'
            }]
        },
        options: {
            responsive: true,
            plugins: { legend: { position: 'top' } },
            scales: { y: { beginAtZero: true } }
        }
    });
}

// FIN DES NOUVELLES FONCTIONS POUR LES CYCLES


    // ========================================================================
    // START: Fonctions de statistiques (optimisées)
    // ========================================================================

    function calculateWeeklyStats() {
        const now = new Date();
        const weekStart = new Date(now);
        weekStart.setDate(now.getDate() - (now.getDay() === 0 ? 6 : now.getDay() - 1));
        weekStart.setHours(0, 0, 0, 0);

        const lastWeekStart = new Date(weekStart);
        lastWeekStart.setDate(lastWeekStart.getDate() - 7);

        let currentWeekVolume = 0;
        let lastWeekVolume = 0;
        const weeklyWorkouts = new Set();
        const muscleVolumes = {};
        let weeklyPRs = 0;

        for (const item of processedData) {
            if (item.date >= weekStart) {
                currentWeekVolume += item.volume;
                weeklyWorkouts.add(item.dateKey);
                if (!muscleVolumes[item.workoutType]) muscleVolumes[item.workoutType] = 0;
                muscleVolumes[item.workoutType] += item.volume;
            } else if (item.date >= lastWeekStart && item.date < weekStart) {
                lastWeekVolume += item.volume;
            }
        }
        
        document.getElementById('weeklyVolume').textContent = currentWeekVolume.toFixed(0) + ' kg';
        document.getElementById('weeklyWorkouts').textContent = weeklyWorkouts.size;
        
        const changeElement = document.getElementById('weeklyChange');
        if (lastWeekVolume > 0) {
            const change = ((currentWeekVolume - lastWeekVolume) / lastWeekVolume * 100);
            changeElement.textContent = (change >= 0 ? '+' : '') + change.toFixed(1) + '%';
            changeElement.className = 'metric-change ' + (change >= 0 ? 'positive' : 'negative');
        } else if (currentWeekVolume > 0) {
             changeElement.textContent = '+100%';
             changeElement.className = 'metric-change positive';
        } else {
            changeElement.textContent = '0%';
            changeElement.className = 'metric-change neutral';
        }

        const topMuscle = Object.entries(muscleVolumes).sort((a, b) => b[1] - a[1])[0];
        if (topMuscle) {
            document.getElementById('topMuscle').textContent = topMuscle[0].toUpperCase();
            document.getElementById('topMuscleVolume').textContent = topMuscle[1].toFixed(0) + ' kg';
        } else {
            document.getElementById('topMuscle').textContent = '-';
            document.getElementById('topMuscleVolume').textContent = '0 kg';
        }
        
        document.getElementById('weeklyPRs').textContent = weeklyPRs;
    }

    function generateVolumeChart() {
        const ctx = document.getElementById('volumeChart');
        if (!ctx) return;
        if (charts.volume) charts.volume.destroy();

        const now = new Date();
        let startDate = new Date();
        if (currentView === 'week') {
            startDate.setDate(now.getDate() - 7);
        } else if (currentView === 'month') {
            startDate.setMonth(now.getMonth() - 1);
        } else { // 'year'
            startDate.setFullYear(now.getFullYear() - 1);
        }
        startDate.setHours(0,0,0,0);
    
        const dailyVolumes = {};
        for (const item of processedData) {
            if (item.date >= startDate) {
                if (!dailyVolumes[item.dateKey]) dailyVolumes[item.dateKey] = 0;
                dailyVolumes[item.dateKey] += item.volume;
            }
        }
    
        const sortedDates = Object.keys(dailyVolumes).sort((a, b) => new Date(a) - new Date(b));
        const labels = sortedDates.map(date => new Date(date).toLocaleDateString('fr-FR', { day: '2-digit', month: '2-digit' }));
        const data = sortedDates.map(date => dailyVolumes[date]);

        charts.volume = new Chart(ctx, {
            type: 'line',
            data: {
                labels: labels,
                datasets: [{
                    label: 'Volume (kg)',
                    data: data,
                    borderColor: 'rgb(75, 192, 192)',
                    backgroundColor: 'rgba(75, 192, 192, 0.2)',
                    tension: 0.1,
                    fill: true
                }]
            },
            options: {
                responsive: true,
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return `Volume: ${context.parsed.y.toFixed(0)} kg`;
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        title: { display: true, text: 'Volume (kg)' }
                    }
                }
            }
        });
    }

    function changeVolumeView(view) {
        currentView = view;
        document.querySelectorAll('.chart-control').forEach(btn => {
            btn.classList.remove('active');
        });
        event.target.classList.add('active');
        generateVolumeChart();
    }

    function generateMuscleChart() {
        const ctx = document.getElementById('muscleChart');
        if (!ctx) return;
        if (charts.muscle) charts.muscle.destroy();
        
        const muscleGroups = { 'Pectoraux': 0, 'Dos': 0, 'Épaules': 0, 'Jambes': 0, 'Bras': 0, 'Abdos': 0 };
        
        for (const item of processedData) {
            const volume = item.volume;
            const workoutType = item.workoutType;
            
            if (workoutType === 'push') {
                muscleGroups['Pectoraux'] += volume * 0.5;
                muscleGroups['Épaules'] += volume * 0.3;
                muscleGroups['Bras'] += volume * 0.2;
            } else if (workoutType === 'pull') {
                muscleGroups['Dos'] += volume * 0.7;
                muscleGroups['Bras'] += volume * 0.3;
            } else if (workoutType === 'leg' || workoutType === 'lower') {
                muscleGroups['Jambes'] += volume;
            } else if (workoutType === 'upper') {
                muscleGroups['Pectoraux'] += volume * 0.3;
                muscleGroups['Dos'] += volume * 0.3;
                muscleGroups['Épaules'] += volume * 0.2;
                muscleGroups['Bras'] += volume * 0.2;
            } else if (workoutType === 'core_a' || workoutType === 'core_b') {
                muscleGroups['Abdos'] += volume;
            }
        }
        
        charts.muscle = new Chart(ctx, {
            type: 'doughnut',
            data: {
                labels: Object.keys(muscleGroups),
                datasets: [{
                    data: Object.values(muscleGroups),
                    backgroundColor: [
                        'rgba(255, 99, 132, 0.8)',
                        'rgba(54, 162, 235, 0.8)',
                        'rgba(255, 206, 86, 0.8)',
                        'rgba(75, 192, 192, 0.8)',
                        'rgba(153, 102, 255, 0.8)',
                        'rgba(255, 159, 64, 0.8)' // Couleur pour Abdos
                    ],
                    borderWidth: 2,
                    borderColor: '#fff'
                }]
            },
            options: {
                responsive: true,
                plugins: {
                    legend: { position: 'bottom', labels: { padding: 15, font: { size: 12 } } },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                const percentage = (total > 0) ? ((context.parsed / total) * 100).toFixed(1) : 0;
                                return `${context.label}: ${context.parsed.toFixed(0)} kg (${percentage}%)`;
                            }
                        }
                    }
                }
            }
        });
    }

    function generateProgramChart() {
        const ctx = document.getElementById('programChart');
        if (!ctx) return;
        if (charts.program) charts.program.destroy();
        
        let programVolumes = { 'A': 0, 'B': 0 };
        
        for (const item of processedData) {
            if (programVolumes[item.program] !== undefined) {
                programVolumes[item.program] += item.volume;
            }
        }
        
        charts.program = new Chart(ctx, {
            type: 'pie',
            data: {
                labels: ['Programme A (Libre)', 'Programme B (Guidé)'],
                datasets: [{
                    data: Object.values(programVolumes),
                    backgroundColor: ['rgba(102, 126, 234, 0.8)', 'rgba(118, 75, 162, 0.8)'],
                    borderWidth: 2,
                    borderColor: '#fff'
                }]
            },
            options: {
                responsive: true,
                plugins: {
                    legend: { position: 'bottom' },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                const percentage = (total > 0) ? ((context.parsed / total) * 100).toFixed(1) : 0;
                                return `${context.label}: ${context.parsed.toFixed(0)} kg (${percentage}%)`;
                            }
                        }
                    }
                }
            }
        });
    }

    function generateCalendar() {
        const container = document.getElementById('calendarGrid');
        if (!container) return;
        
        const now = new Date();
        const currentMonth = now.getMonth();
        const currentYear = now.getFullYear();
        const firstDay = new Date(currentYear, currentMonth, 1);
        const lastDay = new Date(currentYear, currentMonth + 1, 0);
        
        const startPadding = (firstDay.getDay() === 0) ? 6 : firstDay.getDay() - 1;
        
        container.innerHTML = '';
        
        const dayLabels = ['Lun', 'Mar', 'Mer', 'Jeu', 'Ven', 'Sam', 'Dim'];
        dayLabels.forEach(label => {
            const dayLabel = document.createElement('div');
            dayLabel.className = 'calendar-day-label';
            dayLabel.textContent = label;
            container.appendChild(dayLabel);
        });
        
        for (let i = 0; i < startPadding; i++) {
            container.appendChild(document.createElement('div')).className = 'calendar-day empty';
        }
        
        const workoutDays = new Set();
        for (const item of processedData) {
            if (item.date.getMonth() === currentMonth && item.date.getFullYear() === currentYear) {
                workoutDays.add(item.date.getDate());
            }
        }

        for (let day = 1; day <= lastDay.getDate(); day++) {
            const dayElement = document.createElement('div');
            dayElement.className = 'calendar-day';
            dayElement.textContent = day;
            
            if (workoutDays.has(day)) {
                dayElement.classList.add('workout');
                dayElement.title = 'Séance effectuée';
            } else {
                dayElement.classList.add('rest');
            }
            
            if (day === now.getDate()) {
                dayElement.style.border = '3px solid #2196F3';
                dayElement.style.padding = '0'; // Compenser la bordure
            }
            
            container.appendChild(dayElement);
        }
    }

    function generateTopExercisesChart() {
        const ctx = document.getElementById('exercisesChart');
        if (!ctx) return;
        if (charts.exercises) charts.exercises.destroy();
        
        const exerciseData = {};
        for (const item of processedData) {
            if (!exerciseData[item.exerciseName]) {
                exerciseData[item.exerciseName] = 0;
            }
            exerciseData[item.exerciseName] += item.volume;
        }
        
        const sorted = Object.entries(exerciseData)
            .sort((a, b) => b[1] - a[1])
            .slice(0, 5);
        
        charts.exercises = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: sorted.map(e => e[0].length > 20 ? e[0].substring(0, 20) + '...' : e[0]),
                datasets: [{
                    label: 'Volume Total (kg)',
                    data: sorted.map(e => e[1]),
                    backgroundColor: 'rgba(255, 159, 64, 0.8)',
                    borderColor: 'rgba(255, 159, 64, 1)',
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                plugins: { legend: { display: false } },
                scales: { y: { beginAtZero: true, title: { display: true, text: 'Volume (kg)' } } }
            }
        });
    }

    function generateProgressionChart() {
        const ctx = document.getElementById('progressionChart');
        if (!ctx) return;
        if (charts.progression) charts.progression.destroy();
        
        const keyExercises = [
            'Développé couché barre',
            'Squat barre libre',
            'Tractions',
            'RDL (Romanian Deadlift)',
            'Roue Abdominale' // Ajout d'un exo core
        ];
        
        const datasets = [];
        const colors = ['rgb(255, 99, 132)', 'rgb(54, 162, 235)', 'rgb(255, 206, 86)', 'rgb(75, 192, 192)', 'rgb(153, 102, 255)'];
        
        keyExercises.forEach((exerciseName, index) => {
            const exerciseProgression = {}; // {dateKey: maxWeightOrReps}
            const isReps = (exerciseName === 'Tractions');

            for (const item of processedData) {
                if (item.exerciseName === exerciseName) {
                    const value = isReps ? item.reps : item.weight;
                    if (value > 0) {
                        if (!exerciseProgression[item.dateKey] || value > exerciseProgression[item.dateKey]) {
                            exerciseProgression[item.dateKey] = value;
                        }
                    }
                }
            }
            
            const sortedData = Object.keys(exerciseProgression)
                .sort((a,b) => new Date(a) - new Date(b))
                .map(date => ({ x: date, y: exerciseProgression[date] }));

            if (sortedData.length > 0) {
                datasets.push({
                    label: exerciseName,
                    data: sortedData,
                    borderColor: colors[index],
                    backgroundColor: colors[index] + '33',
                    tension: 0.1,
                    yAxisID: isReps ? 'yReps' : 'yWeight' // Axe différent pour les reps
                });
            }
        });
        
        charts.progression = new Chart(ctx, {
            type: 'line',
            data: {
                datasets: datasets
            },
            options: {
                responsive: true,
                plugins: { legend: { position: 'top' } },
                scales: {
                    x: {
                        type: 'time',
                        time: { unit: 'day', tooltipFormat: 'dd MMM yyyy', displayFormats: { day: 'dd/MM' } },
                        title: { display: true, text: 'Date' }
                    },
                    yWeight: { // Axe pour le Poids
                        type: 'linear',
                        position: 'left',
                        beginAtZero: false,
                        title: { display: true, text: 'Poids (kg)' }
                    },
                    yReps: { // Axe pour les Reps (Tractions)
                        type: 'linear',
                        position: 'right',
                        beginAtZero: true,
                        title: { display: true, text: 'Répétitions' },
                        grid: { drawOnChartArea: false } // Ne pas dessiner la grille pour cet axe
                    }
                }
            }
        });
    }


    function generatePRTable() {
        const tbody = document.getElementById('prTableBody');
        if (!tbody) return;

        const prData = {};

        for (const item of processedData) {
            const name = item.exerciseName;
            if (!prData[name]) {
                prData[name] = { 
                    maxWeight: 0, 
                    maxReps: 0, 
                    maxVolume: 0, 
                    weightDate: null, 
                    repsDate: null, 
                    volumeDate: null,
                    category: getExerciseCategory(name)
                };
            }
            // Volume total pour un exercice sur une session
            const sessionVolume = processedData
                .filter(p => p.dateKey === item.dateKey && p.exerciseName === name)
                .reduce((sum, s) => sum + s.volume, 0);

            if (item.weight > prData[name].maxWeight) {
                prData[name].maxWeight = item.weight;
                prData[name].weightDate = item.date;
            }
            if (item.reps > prData[name].maxReps) {
                prData[name].maxReps = item.reps;
                prData[name].repsDate = item.date;
            }
            if (sessionVolume > prData[name].maxVolume) {
                prData[name].maxVolume = sessionVolume;
                prData[name].volumeDate = item.date;
            }
        }

        // Regrouper les exercices par catégorie
        const exercisesByCategory = {};
        Object.entries(prData)
            .filter(([, data]) => data.maxVolume > 0)
            .forEach(([exercise, data]) => {
                const category = data.category;
                if (!exercisesByCategory[category]) {
                    exercisesByCategory[category] = [];
                }
                exercisesByCategory[category].push([exercise, data]);
            });

        // Trier les catégories dans un ordre logique
        const categoryOrder = [
            'Pectoraux', 'Dos', 'Épaules', 
            'Bras (Biceps)', 'Bras (Triceps)',
            'Quadriceps', 'Ischio-jambiers', 'Fessiers/Adducteurs', 
            'Mollets', 'Lombaires', 'Abdominaux', 'Autres'
        ];

        let tableHTML = '';
        const weekAgo = new Date();
        weekAgo.setDate(weekAgo.getDate() - 7);

        categoryOrder.forEach(category => {
            if (!exercisesByCategory[category]) return;

            // Trier les exercices par volume dans la catégorie
            const exercises = exercisesByCategory[category].sort((a, b) => b[1].maxVolume - a[1].maxVolume);

            // Ajouter une ligne d'en-tête de catégorie
            tableHTML += `
                <tr class="category-header">
                    <td colspan="5" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; font-weight: 700; padding: 12px; font-size: 1.1em; text-align: left;">
                        ${category}
                    </td>
                </tr>
            `;

            // Ajouter les exercices de cette catégorie
            exercises.forEach(([exercise, data]) => {
                const isRecent = (date) => date && date > weekAgo;
                
                tableHTML += `
                    <tr>
                        <td class="exercise-name" style="padding-left: 30px;">├─ ${exercise}</td>
                        <td>
                            ${data.maxWeight} kg
                            ${isRecent(data.weightDate) ? '<span class="pr-badge">NEW!</span>' : ''}
                        </td>
                        <td>
                            ${data.maxReps}
                            ${isRecent(data.repsDate) ? '<span class="pr-badge">NEW!</span>' : ''}
                        </td>
                        <td>
                            ${data.maxVolume.toFixed(0)} kg
                            ${isRecent(data.volumeDate) ? '<span class="pr-badge">NEW!</span>' : ''}
                        </td>
                        <td>${data.volumeDate ? data.volumeDate.toLocaleDateString('fr-FR') : 'N/A'}</td>
                    </tr>
                `;
            });
        });

        tbody.innerHTML = tableHTML;
    }

    function generateInsights() {
        const insights = [];
        const now = new Date();
        const lastWeek = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
        const twoWeeksAgo = new Date(now.getTime() - 14 * 24 * 60 * 60 * 1000);
        
        let currentWeekVolume = 0;
        let lastWeekVolume = 0;
        let muscleBalance = { push: 0, pull: 0, legs: 0, core: 0 };

        for (const item of processedData) {
            if (item.date > lastWeek) {
                currentWeekVolume += item.volume;
            } else if (item.date > twoWeeksAgo) {
                lastWeekVolume += item.volume;
            }
            
            const workoutType = item.workoutType;
            if (workoutType === 'push' || workoutType === 'upper') muscleBalance.push += item.volume;
            else if (workoutType === 'pull') muscleBalance.pull += item.volume;
            else if (workoutType === 'leg' || workoutType === 'lower') muscleBalance.legs += item.volume;
            else if (workoutType === 'core_a' || workoutType === 'core_b') muscleBalance.core += item.volume;

        }
        
        if (lastWeekVolume > 0 && currentWeekVolume > lastWeekVolume * 1.1) {
            insights.push({ type: 'success', icon: '📈', text: `Excellente progression ! Volume en hausse de ${Math.round((currentWeekVolume - lastWeekVolume) / lastWeekVolume * 100)}% cette semaine.` });
        } else if (lastWeekVolume > 0 && currentWeekVolume < lastWeekVolume * 0.9) {
            insights.push({ type: 'warning', icon: '⚠️', text: 'Volume en baisse cette semaine. Fatigue accumulée ?' });
        }
        
        const pushPullRatio = muscleBalance.push / (muscleBalance.pull || 1);
        if (pushPullRatio > 1.5) {
            insights.push({ type: 'warning', icon: '⚖️', text: `Déséquilibre Push/Pull détecté (ratio ${pushPullRatio.toFixed(1)}:1). Augmentez le volume de tirage.` });
        } else if (pushPullRatio < 0.7 && pushPullRatio > 0) {
            insights.push({ type: 'warning', icon: '⚖️', text: `Déséquilibre Pull/Push détecté (ratio 1:${(1/pushPullRatio).toFixed(1)}). Augmentez le volume de poussée.` });
        } else {
            insights.push({ type: 'success', icon: '✅', text: 'Excellent équilibre Push/Pull maintenu.' });
        }
        
        const totalVolume = muscleBalance.push + muscleBalance.pull + muscleBalance.legs;
        if(totalVolume > 0) {
            const legPercentage = (muscleBalance.legs / totalVolume * 100);
            if (legPercentage < 30) {
                insights.push({ type: 'warning', icon: '🦵', text: `Volume jambes faible (${legPercentage.toFixed(0)}% du total).` });
            } else {
                insights.push({ type: 'info', icon: '💪', text: `Bon équilibre haut/bas du corps (${legPercentage.toFixed(0)}% jambes).` });
            }
        }

        const workoutDates = [...new Set(processedData.map(item => item.dateKey))].map(d => new Date(d)).sort((a,b) => b - a);
        if (workoutDates.length > 1) {
            const daysBetween = Math.floor((workoutDates[0] - workoutDates[1]) / (1000 * 60 * 60 * 24));
            if (daysBetween > 3) {
                insights.push({ type: 'info', icon: '📅', text: `${daysBetween} jours depuis la dernière séance. Restez régulier !` });
            }
        }
        
        const container = document.getElementById('insightsList');
        if (container) {
            container.innerHTML = insights.map(insight => `
                <div class="insight-item">
                    <div class="insight-icon ${insight.type}">${insight.icon}</div>
                    <div>${insight.text}</div>
                </div>
            `).join('') || '<div class="insight-item"><div class="insight-icon info">💡</div><div>Pas assez de données pour générer des insights. Continuez !</div></div>';
        }
    }

    function generateStrengthStandards() {
        const container = document.getElementById('strengthStandards');
        if (!container) return;
        
        const standards = {
            'Développé couché barre': { beginner: 0.5, novice: 0.75, intermediate: 1.0, advanced: 1.5, elite: 2.0 },
            'Squat barre libre': { beginner: 0.75, novice: 1.25, intermediate: 1.5, advanced: 2.0, elite: 2.5 },
            'Tractions': { beginner: 0, novice: 5, intermediate: 10, advanced: 15, elite: 20 },
            'RDL (Romanian Deadlift)': { beginner: 0.5, novice: 1.0, intermediate: 1.5, advanced: 2.0, elite: 2.5 }
        };
        
        const bodyWeight = 90; // Configurable
        let html = '';
        const userBests = {};

        for (const item of processedData) {
            if (standards[item.exerciseName]) {
                if (!userBests[item.exerciseName]) userBests[item.exerciseName] = { bestWeight: 0, bestReps: 0 };
                if (item.exerciseName === 'Tractions') {
                    userBests[item.exerciseName].bestReps = Math.max(userBests[item.exerciseName].bestReps, item.reps);
                } else {
                    userBests[item.exerciseName].bestWeight = Math.max(userBests[item.exerciseName].bestWeight, item.weight);
                }
            }
        }
        
        Object.entries(standards).forEach(([exercise, levels]) => {
            const userBestData = userBests[exercise];
            if (userBestData) {
                const isReps = (exercise === 'Tractions');
                const userBest = isReps ? userBestData.bestReps : userBestData.bestWeight;
                
                if (userBest > 0) {
                    let userPosition = 0;
                    if (isReps) {
                        userPosition = (userBest / levels.elite * 100);
                    } else {
                        const ratio = userBest / bodyWeight;
                        userPosition = (ratio / levels.elite * 100);
                    }
                    
                    html += `
                        <div style="margin-bottom: 30px;">
                            <h4 style="margin-bottom: 10px;">${exercise}</h4>
                            <div class="standard-bar">
                                <div class="standard-segment beginner">Débutant</div>
                                <div class="standard-segment novice">Novice</div>
                                <div class="standard-segment intermediate">Inter.</div>
                                <div class="standard-segment advanced">Avancé</div>
                                <div class="standard-segment elite">Elite</div>
                                <div class="standard-marker" style="left: ${Math.min(userPosition, 100)}%"></div>
                            </div>
                            <div style="text-align: center; margin-top: 10px; color: #666;">
                                Votre meilleur: ${userBest}${isReps ? ' reps' : ' kg'}
                            </div>
                        </div>
                    `;
                }
            }
        });
        
        container.innerHTML = html;
    }

    function generateBalanceChart() {
        const ctx = document.getElementById('balanceChart');
        if (!ctx) return;
        if (charts.balance) charts.balance.destroy();
        
        let muscleVolumes = { Push: 0, Pull: 0, Legs: 0, Core: 0 };
        for (const item of processedData) {
            const workoutType = item.workoutType;
            if (workoutType === 'push') muscleVolumes.Push += item.volume;
            else if (workoutType === 'pull') muscleVolumes.Pull += item.volume;
            else if (workoutType === 'leg' || workoutType === 'lower') muscleVolumes.Legs += item.volume;
            else if (workoutType === 'core_a' || workoutType === 'core_b') muscleVolumes.Core += item.volume;
            else if (workoutType === 'upper') {
                muscleVolumes.Push += item.volume * 0.5;
                muscleVolumes.Pull += item.volume * 0.5;
            }
        }
        
        charts.balance = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: Object.keys(muscleVolumes),
                datasets: [{
                    label: 'Volume Total (kg)',
                    data: Object.values(muscleVolumes),
                    backgroundColor: ['rgba(255, 99, 132, 0.8)', 'rgba(54, 162, 235, 0.8)', 'rgba(75, 192, 192, 0.8)', 'rgba(255, 159, 64, 0.8)']
                }]
            },
            options: {
                responsive: true,
                plugins: { legend: { display: false } },
                scales: { y: { beginAtZero: true } }
            }
        });
    }

    function generateFatigueChart() {
        const ctx = document.getElementById('fatigueChart');
        if (!ctx) return;
        if (charts.fatigue) charts.fatigue.destroy();
        
        const dailyVolumes = {};
        for (const item of processedData) {
            if (!dailyVolumes[item.dateKey]) dailyVolumes[item.dateKey] = 0;
            dailyVolumes[item.dateKey] += item.volume;
        }
        
        const sortedDates = Object.keys(dailyVolumes).sort((a, b) => new Date(a) - new Date(b));
        const labels = sortedDates.map(date => new Date(date).toLocaleDateString('fr-FR', { day: '2-digit', month: '2-digit' }));
        const volumes = sortedDates.map(date => dailyVolumes[date]);
        
        const averages = [];
        for (let i = 0; i < volumes.length; i++) {
            if (i >= 2) {
                const avg = (volumes[i] + volumes[i-1] + volumes[i-2]) / 3;
                averages.push(avg);
            } else {
                averages.push(null); 
            }
        }
        
        charts.fatigue = new Chart(ctx, {
            type: 'line',
            data: {
                labels: labels,
                datasets: [{
                    label: 'Volume par séance',
                    data: volumes,
                    borderColor: 'rgba(75, 192, 192, 0.5)',
                    backgroundColor: 'rgba(75, 192, 192, 0.1)',
                    tension: 0.1
                }, {
                    label: 'Moyenne mobile (3 séances)',
                    data: averages,
                    borderColor: 'rgba(255, 99, 132, 1)',
                    backgroundColor: 'rgba(255, 99, 132, 0.1)',
                    borderWidth: 3,
                    tension: 0.3,
                    spanGaps: true 
                }]
            },
            options: {
                responsive: true,
                plugins: { legend: { position: 'top' } },
                scales: { y: { beginAtZero: true, title: { display: true, text: 'Volume (kg)' } } }
            }
        });
    }
    
    function generatePredictions() {
        const container = document.getElementById('predictionGrid');
        if (!container) return;
        
        const predictions = [];
        const keyExercises = ['Développé couché barre', 'Squat barre libre', 'Tractions', 'RDL (Romanian Deadlift)'];
        
        keyExercises.forEach(exerciseName => {
            const progression = []; 
            const sessionBests = {}; 
            
            for (const item of processedData) {
                if (item.exerciseName === exerciseName) {
                    const value = (exerciseName === 'Tractions') ? item.reps : item.weight;
                    if (value > 0) {
                        if (!sessionBests[item.dateKey] || value > sessionBests[item.dateKey]) {
                            sessionBests[item.dateKey] = value;
                        }
                    }
                }
            }
            
            const sortedDates = Object.keys(sessionBests).sort((a,b) => new Date(a) - new Date(b));
            sortedDates.forEach(date => {
                progression.push({ date: new Date(date), value: sessionBests[date] });
            });

            if (progression.length >= 3) {
                const n = progression.length;
                const x = progression.map((_, i) => i); 
                const y = progression.map(p => p.value);
                
                const sumX = x.reduce((a, b) => a + b, 0);
                const sumY = y.reduce((a, b) => a + b, 0);
                const sumXY = x.reduce((a, b, i) => a + b * y[i], 0);
                const sumX2 = x.reduce((a, b) => a + b * b, 0);
                
                const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
                
                if (slope > 0) { 
                    const intercept = (sumY - slope * sumX) / n;
                    const predicted = intercept + slope * (n + 4); 
                    
                    predictions.push({
                        exercise: exerciseName,
                        current: y[y.length - 1],
                        predicted: predicted.toFixed(1),
                        date: new Date(Date.now() + 4 * 7 * 24 * 60 * 60 * 1000),
                        unit: (exerciseName === 'Tractions') ? 'reps' : 'kg'
                    });
                }
            }
        });
        
        container.innerHTML = predictions.map(pred => `
            <div class="prediction-card">
                <div class="prediction-exercise">${pred.exercise}</div>
                <div class="prediction-value">${pred.predicted} ${pred.unit}</div>
                <div class="prediction-date">Objectif: ${pred.date.toLocaleDateString('fr-FR')}</div>
                <div style="margin-top: 10px; opacity: 0.8;">Actuel: ${pred.current} ${pred.unit}</div>
            </div>
        `).join('') || '<div class="prediction-card"><div class="prediction-exercise">Pas de prédictions</div><div class="prediction-value">📈</div><div class="prediction-date">Continuez à vous entraîner !</div></div>';
    }

    // ========================================================================
    // FIN: Refonte des fonctions de statistiques
    // ========================================================================

    // Goals management
    function initializeGoals() {
        const select = document.getElementById('goalExercise');
        const allExercises = new Set();
        
		Object.values(workouts).forEach(program => {
    Object.values(program).forEach(workout => {
        workout.forEach(exercise => {
            if (exercise.isSuperset) {
                // Ajouter chaque exercice du superset
                exercise.exercises.forEach(subEx => {
                    allExercises.add(subEx.name);
                });
            } else {
                allExercises.add(exercise.name);
            }
        });
    });
});
        
        select.innerHTML = '<option value="">Sélectionner un exercice</option>';
        [...allExercises].sort().forEach(exercise => {
            select.innerHTML += `<option value="${exercise}">${exercise}</option>`;
        });
        
        const defaultDate = new Date();
        defaultDate.setMonth(defaultDate.getMonth() + 3);
        document.getElementById('goalDate').value = defaultDate.toISOString().split('T')[0];
    }
    
    function openGoalModal() {
        document.getElementById('goalModal').classList.add('active');
    }
    
    function closeGoalModal() {
        document.getElementById('goalModal').classList.remove('active');
        document.getElementById('goalExercise').value = '';
        document.getElementById('goalType').value = 'weight';
        document.getElementById('goalValue').value = '';
    }
    
    // Fonctions pour la modale d'aide
    function openHelpModal() {
        document.getElementById('helpModal').classList.add('active');
        document.body.style.overflow = 'hidden'; // Empêcher le scroll de la page
    }
    
    function closeHelpModal() {
        document.getElementById('helpModal').classList.remove('active');
        document.body.style.overflow = 'auto'; // Rétablir le scroll
    }
    
    function saveGoal() {
        const exercise = document.getElementById('goalExercise').value;
        const type = document.getElementById('goalType').value;
        const value = parseFloat(document.getElementById('goalValue').value);
        const date = document.getElementById('goalDate').value;
        
        if (!exercise || !value || !date) {
            showToast('Veuillez remplir tous les champs');
            return;
        }
        
        const goal = {
            id: Date.now(),
            exercise, type, value, date,
            completed: false,
            createdAt: new Date().toISOString()
        };
        
        goals.push(goal);
        localStorage.setItem('workoutGoals', JSON.stringify(goals));
        
        closeGoalModal();
        displayGoals();
        showToast('Objectif ajouté !');
    }
    
    function displayGoals() {
        const activeContainer = document.getElementById('goalsList');
        const completedContainer = document.getElementById('completedGoalsList');
        if (!activeContainer || !completedContainer) return;
        
        const activeGoals = goals.filter(g => !g.completed);
        const completedGoals = goals.filter(g => g.completed);
        
        activeContainer.innerHTML = activeGoals.map(goal => {
            const progress = calculateGoalProgress(goal);
            const daysLeft = Math.ceil((new Date(goal.date) - new Date()) / (1000 * 60 * 60 * 24));
            
            return `
                <div class="goal-item">
                    <div class="goal-info">
                        <div class="goal-icon">🎯</div>
                        <div class="goal-details">
                            <div class="goal-name">${goal.exercise}</div>
                            <div style="color: #666; font-size: 0.9em;">
                                ${goal.value} ${goal.type === 'weight' ? 'kg' : 'reps'} - 
                                ${daysLeft > 0 ? daysLeft + ' jours restants' : 'Terminé'}
                            </div>
                        </div>
                    </div>
                    <div class="goal-progress">
                        <div class="goal-progress-bar" style="width: ${progress}%"></div>
                    </div>
                    <span class="goal-value">${progress.toFixed(0)}%</span>
                </div>
            `;
        }).join('') || '<p style="color: #999; text-align: center;">Aucun objectif actif</p>';
        
        completedContainer.innerHTML = completedGoals.map(goal => `
            <div class="goal-item" style="opacity: 0.7;">
                <div class="goal-info">
                    <div class="goal-icon">✅</div>
                    <div class="goal-details">
                        <div class="goal-name">${goal.exercise}</div>
                        <div style="color: #666; font-size: 0.9em;">
                            ${goal.value} ${goal.type === 'weight' ? 'kg' : 'reps'}
                        </div>
                    </div>
                </div>
                <span style="color: #4caf50;">Complété !</span>
            </div>
        `).join('') || '<p style="color: #999; text-align: center;">Aucun objectif complété</p>';
    }
    
    function calculateGoalProgress(goal) {
        let currentBest = 0;
        for (const item of processedData) {
            if (item.exerciseName === goal.exercise) {
                if (goal.type === 'weight') {
                    currentBest = Math.max(currentBest, item.weight);
                } else if (goal.type === 'reps') {
                    currentBest = Math.max(currentBest, item.reps);
                } else if (goal.type === 'volume') {
                    currentBest = Math.max(currentBest, item.volume);
                }
            }
        }
        
        const progress = (goal.value > 0) ? (currentBest / goal.value) * 100 : 0;
        
        if (progress >= 100 && !goal.completed) {
            goal.completed = true;
            localStorage.setItem('workoutGoals', JSON.stringify(goals));
            showToast(`🎉 Objectif atteint: ${goal.exercise} !`);
        }
        
        return Math.min(progress, 100);
    }
    
    function checkForPRs(key, data) {
        // ...
    }
    
    function calculateStreak() {
        const workoutDates = new Set();
        for (const item of processedData) {
            workoutDates.add(item.dateKey);
        }
        
        const dates = Array.from(workoutDates).map(d => new Date(d)).sort((a, b) => b - a);
        
        if (dates.length === 0) {
            document.getElementById('streakDays').textContent = '0';
            return;
        }
        
        let streak = 0;
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        
        const lastWorkout = new Date(dates[0]);
        lastWorkout.setHours(0, 0, 0, 0);
        
        const daysDiff = Math.floor((today - lastWorkout) / (1000 * 60 * 60 * 24));
        
        if (daysDiff > 2) { 
            document.getElementById('streakDays').textContent = '0';
            return;
        }

        streak = 1;
        
        for (let i = 1; i < dates.length; i++) {
            const current = new Date(dates[i - 1]);
            const previous = new Date(dates[i]);
            current.setHours(0, 0, 0, 0);
            previous.setHours(0, 0, 0, 0);
            
            const diff = Math.floor((current - previous) / (1000 * 60 * 60 * 24));
            
            if (diff <= 3) { 
                streak++;
            } else {
                break;
            }
        }
        
        document.getElementById('streakDays').textContent = streak;
    }
    
    // Tab switching (Lazy loading des graphiques)
   function switchTab(tabName) {
    document.querySelectorAll('.tab-content').forEach(content => {
        content.classList.remove('active');
    });
    document.querySelectorAll('.dashboard-tab').forEach(tab => {
        tab.classList.remove('active');
    });
    
    document.getElementById(tabName).classList.add('active');
    event.target.classList.add('active');
    
    try {
        // NOUVEAUX ONGLETS
        if (tabName === 'programA') {
            displayCycleCard('A', 'cycleCardProgramA');
            displayCycleComparison('A', 'comparisonGridProgramA');
            generateMuscleChartByProgram('A', 'muscleChartProgramA');
            generateProgressionChartByProgram('A', 'progressionChartProgramA');
            // Phase 2: Stats avancées pour Programme A
            updatePushPullLegsDisplay('A');
            updateFatigueDisplay('A');
            updateRecordsDisplay('A');
            // Phase 3: Insights & Prédictions pour Programme A
            displayInsights('A');
            displayRatioLibreGuide();
            displayPredictions('A');
        } else if (tabName === 'programB') {
            displayCycleCard('B', 'cycleCardProgramB');
            displayCycleComparison('B', 'comparisonGridProgramB');
            generateMuscleChartByProgram('B', 'muscleChartProgramB');
            generateProgressionChartByProgram('B', 'progressionChartProgramB');
            // Phase 2: Stats avancées pour Programme B
            updatePushPullLegsDisplay('B');
            updateFatigueDisplay('B');
            updateRecordsDisplay('B');
            // Phase 3: Insights & Prédictions pour Programme B
            displayInsights('B');
            displayPredictions('B');
        } else if (tabName === 'comparison') {
            generateComparisonMetrics();
            generateComparisonEvolutionChart();
            generateWorkoutTypeComparisonChart();
        }
        // ONGLETS EXISTANTS
        else if (tabName === 'progress') {
            generateTopExercisesChart();
            generateProgressionChart();
            generatePredictions();
            generateStrengthStandards();
        } else if (tabName === 'records') {
            generatePRTable();
        } else if (tabName === 'analysis') {
            generateBalanceChart();
            generateFatigueChart();
            generateInsights();
        } else if (tabName === 'goals') {
            displayGoals();
        }
    } catch (e) {
        console.error(`Erreur lors du changement d'onglet vers ${tabName}:`, e);
        showToast("Erreur lors de l'affichage de cet onglet.");
    }
}

    // Export functions
    function toggleExportMenu() {
        const menu = document.getElementById('exportMenu');
        menu.classList.toggle('active');
    }
    
    function exportPDF() {
        toggleExportMenu();
        window.print();
        showToast('Utilisez Ctrl+P pour sauvegarder en PDF');
    }
    
    function exportCSV() {
        toggleExportMenu();
        
        let csv = 'Date,Programme,Séance,Exercice,Série,Reps,Poids,Volume\n';
        
        for (const item of processedData) {
            csv += `${item.dateKey},${item.program},${item.workoutType},"${item.exerciseName}",${item.set},${item.reps},${item.weight},${item.volume}\n`;
        }
        
        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `workout-data-${new Date().toISOString().split('T')[0]}.csv`;
        link.click();
        
        showToast('Données exportées en CSV !');
    }
    
    function shareStats() {
        toggleExportMenu();
        const stats = `🏋️ Mes Stats Musculation 
📊 Volume hebdo: ${document.getElementById('weeklyVolume').textContent}
💪 Séances: ${document.getElementById('weeklyWorkouts').textContent}
🔥 Série: ${document.getElementById('streakDays').textContent} jours`;
        
        if (navigator.share) {
            navigator.share({ title: 'Mes Stats Musculation', text: stats });
        } else {
            navigator.clipboard.writeText(stats);
            showToast('Stats copiées dans le presse-papier !');
        }
    }
    
    // Data import/export
    function exportData() {
        const dataStr = JSON.stringify(workoutData, null, 2);
        const dataBlob = new Blob([dataStr], {type: 'application/json'});
        const url = URL.createObjectURL(dataBlob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `workout-data-${new Date().toISOString().split('T')[0]}.json`;
        link.click();
        showToast('Données exportées !');
    }
    
    function importData(event) {
        const file = event.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = async function(e) {
            try {
                workoutData = JSON.parse(e.target.result);
                localStorage.setItem('workoutData', JSON.stringify(workoutData));
                
                // SYNC AU SERVEUR IMMÉDIATEMENT APRÈS IMPORT
                await syncToServer(workoutData);
                
                processAllData();
                
                if (currentWorkout && currentWorkout !== 'stats') {
                    loadData();
                } else if (currentWorkout === 'stats') {
                    showStats(); 
                }
                calculateStreak();
                showToast('✅ Données importées et synchronisées !');
            } catch (error) {
                console.error("Erreur d'import:", error);
                showToast("❌ Erreur lors de l'import");
            }
        };
        reader.readAsText(file);
    }
    
    function clearDay() {
        if (!confirm('Êtes-vous sûr de vouloir effacer les données de ce jour ?')) return;
        
        const key = getDataKey();
        delete workoutData[key];
        localStorage.setItem('workoutData', JSON.stringify(workoutData));
        
        processAllData();
        
        if (currentWorkout && currentWorkout !== 'stats') {
            generateTable(currentWorkout); 
        }
        
        updateStats(); 
        showToast('Données effacées');
    }
    
    // Toast notification
    function showToast(message) {
        const toast = document.getElementById('toast');
        if (!toast) return;
        toast.textContent = message;
        toast.classList.add('show');
        setTimeout(() => {
            toast.classList.remove('show');
        }, 3000);
    }
    
    // Date change handler
    document.getElementById('dateSelector').addEventListener('change', function() {
        if (currentWorkout && currentWorkout !== 'stats') {
            loadData();
        }
    });
    
    // Close modals on click outside
    window.onclick = function(event) {
        const modal = document.getElementById('goalModal');
        if (event.target === modal) {
            closeGoalModal();
        }
        
        const helpModal = document.getElementById('helpModal');
        if (event.target === helpModal) {
            closeHelpModal();
        }
        
        const exportMenu = document.getElementById('exportMenu');
        if (exportMenu && !event.target.closest('.export-section') && exportMenu.classList.contains('active')) {
            exportMenu.classList.remove('active');
        }
    }
</script>

<!-- ============================================
     CHRONOMÈTRE TEMPS DE REPOS - HTML
     ============================================ -->

<!-- Bouton flottant -->
<button class="rest-timer-fab" onclick="openRestTimer()" id="restTimerFab">
    <span class="fab-icon">⏱️</span>
</button>

<!-- Modal du chronomètre -->
<div class="rest-timer-modal" id="restTimerModal">
    <div class="rest-timer-content">
        <div class="rest-timer-header">
            <h2 class="rest-timer-title">⏱️ Temps de Repos</h2>
            <button class="rest-timer-close" onclick="closeRestTimer()">×</button>
        </div>
        
        <div class="rest-timer-display">
            <div class="rest-timer-time green" id="restTimerTime">00:00</div>
        </div>
        
        <div class="rest-timer-progress">
            <div class="rest-timer-progress-bar green" id="restTimerProgressBar" style="width: 100%"></div>
        </div>
        
        <div class="rest-timer-status" id="restTimerStatus">Sélectionne un temps</div>
        
        <div class="rest-timer-presets">
            <button class="rest-timer-preset" onclick="setRestTime(30)">30s</button>
            <button class="rest-timer-preset" onclick="setRestTime(60)">1min</button>
            <button class="rest-timer-preset" onclick="setRestTime(90)">1min30</button>
            <button class="rest-timer-preset" onclick="setRestTime(120)">2min</button>
            <button class="rest-timer-preset" onclick="setRestTime(180)">3min</button>
            <button class="rest-timer-preset" onclick="setRestTime(300)">5min</button>
        </div>
        
        <div class="rest-timer-controls">
            <button class="rest-timer-btn rest-timer-btn-start" onclick="startRestTimer()" id="restTimerStartBtn">
                ▶️ Start
            </button>
            <button class="rest-timer-btn rest-timer-btn-pause" onclick="pauseRestTimer()" id="restTimerPauseBtn" style="display: none;">
                ⏸️ Pause
            </button>
            <button class="rest-timer-btn rest-timer-btn-reset" onclick="resetRestTimer()">
                🔄 Reset
            </button>
        </div>
    </div>
</div>

<script>
    // ============================================
    // CHRONOMÈTRE TEMPS DE REPOS - JAVASCRIPT
    // ============================================
    
    let restTimerInterval = null;
    let restTimerSeconds = 0;
    let restTimerTotal = 0;
    let restTimerRunning = false;
    
    function openRestTimer() {
        document.getElementById('restTimerModal').classList.add('active');
    }
    
    function closeRestTimer() {
        document.getElementById('restTimerModal').classList.remove('active');
        if (restTimerRunning) {
            pauseRestTimer();
        }
    }
    
    function setRestTime(seconds) {
        // Reset timer
        if (restTimerRunning) {
            pauseRestTimer();
        }
        
        restTimerSeconds = seconds;
        restTimerTotal = seconds;
        
        // Update UI
        updateRestTimerDisplay();
        document.getElementById('restTimerStatus').textContent = 'Prêt à démarrer';
        
        // Highlight selected preset
        document.querySelectorAll('.rest-timer-preset').forEach(btn => {
            btn.classList.remove('active');
        });
        event.target.classList.add('active');
    }
    
    function startRestTimer() {
        if (restTimerSeconds === 0 || restTimerTotal === 0) {
            showToast('⏱️ Sélectionne d\'abord un temps de repos');
            return;
        }
        
        if (restTimerRunning) return;
        
        restTimerRunning = true;
        document.getElementById('restTimerStartBtn').style.display = 'none';
        document.getElementById('restTimerPauseBtn').style.display = 'block';
        document.getElementById('restTimerStatus').textContent = 'En cours...';
        
        restTimerInterval = setInterval(() => {
            restTimerSeconds--;
            updateRestTimerDisplay();
            
            if (restTimerSeconds <= 0) {
                restTimerComplete();
            }
        }, 1000);
    }
    
    function pauseRestTimer() {
        if (!restTimerRunning) return;
        
        restTimerRunning = false;
        clearInterval(restTimerInterval);
        
        document.getElementById('restTimerStartBtn').style.display = 'block';
        document.getElementById('restTimerPauseBtn').style.display = 'none';
        document.getElementById('restTimerStatus').textContent = 'En pause';
    }
    
    function resetRestTimer() {
        pauseRestTimer();
        restTimerSeconds = restTimerTotal;
        updateRestTimerDisplay();
        document.getElementById('restTimerStatus').textContent = 'Prêt à démarrer';
    }
    
    function updateRestTimerDisplay() {
        const minutes = Math.floor(restTimerSeconds / 60);
        const seconds = restTimerSeconds % 60;
        const timeString = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        
        const timeDisplay = document.getElementById('restTimerTime');
        const progressBar = document.getElementById('restTimerProgressBar');
        
        timeDisplay.textContent = timeString;
        
        // Calculate percentage
        const percentage = restTimerTotal > 0 ? (restTimerSeconds / restTimerTotal) * 100 : 0;
        progressBar.style.width = percentage + '%';
        
        // Update colors based on time remaining
        timeDisplay.classList.remove('green', 'orange', 'red');
        progressBar.classList.remove('green', 'orange', 'red');
        
        if (percentage > 50) {
            timeDisplay.classList.add('green');
            progressBar.classList.add('green');
        } else if (percentage > 20) {
            timeDisplay.classList.add('orange');
            progressBar.classList.add('orange');
        } else {
            timeDisplay.classList.add('red');
            progressBar.classList.add('red');
        }
    }
    
    function restTimerComplete() {
        pauseRestTimer();
        
        // Play sound
        playRestTimerSound();
        
        // Vibrate on mobile
        if (navigator.vibrate) {
            navigator.vibrate([200, 100, 200, 100, 200]);
        }
        
        // Update UI
        document.getElementById('restTimerStatus').textContent = '✅ Temps de repos terminé !';
        showToast('⏱️ Temps de repos terminé ! C\'est reparti ! 💪');
        
        // Flash the display
        const timeDisplay = document.getElementById('restTimerTime');
        let flashCount = 0;
        const flashInterval = setInterval(() => {
            timeDisplay.style.opacity = timeDisplay.style.opacity === '0' ? '1' : '0';
            flashCount++;
            if (flashCount >= 6) {
                clearInterval(flashInterval);
                timeDisplay.style.opacity = '1';
            }
        }, 300);
    }
    
    function playRestTimerSound() {
        // Create audio context
        try {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            // Create oscillator (beep sound)
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            // Configure sound
            oscillator.frequency.value = 800; // Frequency in Hz
            oscillator.type = 'sine';
            
            // Volume envelope
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(0.3, audioContext.currentTime + 0.01);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
            
            // Play sound
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.5);
            
            // Second beep
            setTimeout(() => {
                const oscillator2 = audioContext.createOscillator();
                const gainNode2 = audioContext.createGain();
                
                oscillator2.connect(gainNode2);
                gainNode2.connect(audioContext.destination);
                
                oscillator2.frequency.value = 1000;
                oscillator2.type = 'sine';
                
                gainNode2.gain.setValueAtTime(0, audioContext.currentTime);
                gainNode2.gain.linearRampToValueAtTime(0.3, audioContext.currentTime + 0.01);
                gainNode2.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                
                oscillator2.start(audioContext.currentTime);
                oscillator2.stop(audioContext.currentTime + 0.5);
            }, 300);
        } catch (e) {
            console.log('Audio not supported');
        }
    }
    
    // Close modal on outside click
    document.addEventListener('click', function(event) {
        const modal = document.getElementById('restTimerModal');
        if (event.target === modal) {
            closeRestTimer();
        }
    });

// ========================================
// PHASE 2: FONCTIONS POUR LES NOUVELLES STATS
// ========================================

/**
 * Catégorisation des exercices par groupe musculaire
 */
const muscleCategories = {
    // PUSH (Poussée)
    push: [
        'développé', 'press', 'pec', 'dips', 'triceps', 'extension', 'élévations latérales',
        'lateral raise', 'militaire', 'épaules', 'shoulder', 'incliné', 'supine', 'fly'
    ],
    // PULL (Traction)
    pull: [
        'tractions', 'pull', 'rowing', 'row', 'tirage', 'curl', 'biceps', 'shrugs',
        'oiseau', 'reverse', 'peck deck'
    ],
    // LEGS (Jambes)
    legs: [
        'squat', 'fentes', 'lunge', 'rdl', 'deadlift', 'leg', 'mollets', 'calf',
        'hack', 'presse', 'extensions lombaires', 'abducteurs', 'adductions'
    ]
};

/**
 * Détermine la catégorie Push/Pull/Legs d'un exercice
 */
function categorizeExercise(exerciseName) {
    const name = exerciseName.toLowerCase();
    
    for (const [category, keywords] of Object.entries(muscleCategories)) {
        if (keywords.some(keyword => name.includes(keyword))) {
            return category;
        }
    }
    
    return 'other'; // Si non catégorisé
}

/**
 * Calcule l'équilibre Push/Pull/Legs pour un programme donné
 */
function calculatePushPullLegsBalance(program) {
    const balance = { push: 0, pull: 0, legs: 0 };
    let totalVolume = 0;
    
    // Parcourir toutes les données de workout
    Object.keys(workoutData).forEach(key => {
        const [keyProgram, workout, date] = key.split('_');
        
        // Ne traiter que le programme demandé
        if (keyProgram !== program) return;
        
        const sessionData = workoutData[key];
        const exercises = workouts[program][workout];
        
        if (!exercises) return;
        
        // Parcourir les exercices de la session
        exercises.forEach((exercise, idx) => {
            const exerciseData = sessionData[idx];
            if (!exerciseData || !exerciseData.reps || !exerciseData.weight) return;
            
            // Calculer le volume de l'exercice
            const totalReps = exerciseData.reps.reduce((sum, r) => sum + (parseInt(r) || 0), 0);
            const volume = totalReps * (parseFloat(exerciseData.weight) || 0);
            
            // Catégoriser et ajouter au volume
            const category = categorizeExercise(exercise.name);
            if (balance[category] !== undefined) {
                balance[category] += volume;
                totalVolume += volume;
            }
        });
    });
    
    // Calculer les pourcentages
    const percentages = {};
    if (totalVolume > 0) {
        percentages.push = Math.round((balance.push / totalVolume) * 100);
        percentages.pull = Math.round((balance.pull / totalVolume) * 100);
        percentages.legs = Math.round((balance.legs / totalVolume) * 100);
    } else {
        percentages.push = 0;
        percentages.pull = 0;
        percentages.legs = 0;
    }
    
    return { volumes: balance, percentages, totalVolume };
}

/**
 * Met à jour l'affichage de l'équilibre Push/Pull/Legs
 */
function updatePushPullLegsDisplay(program) {
    const programId = program === 'A' ? 'ProgramA' : 'ProgramB';
    const balance = calculatePushPullLegsBalance(program);
    
    // Mettre à jour les barres et les valeurs
    const pushBar = document.getElementById(`pushBar${programId}`);
    const pullBar = document.getElementById(`pullBar${programId}`);
    const legsBar = document.getElementById(`legsBar${programId}`);
    
    const pushValue = document.getElementById(`pushValue${programId}`);
    const pullValue = document.getElementById(`pullValue${programId}`);
    const legsValue = document.getElementById(`legsValue${programId}`);
    
    if (pushBar && pullBar && legsBar) {
        pushBar.style.width = balance.percentages.push + '%';
        pullBar.style.width = balance.percentages.pull + '%';
        legsBar.style.width = balance.percentages.legs + '%';
    }
    
    if (pushValue && pullValue && legsValue) {
        pushValue.textContent = balance.percentages.push + '%';
        pullValue.textContent = balance.percentages.pull + '%';
        legsValue.textContent = balance.percentages.legs + '%';
    }
    
    // Vérifier les déséquilibres et afficher une alerte si nécessaire
    const alertDiv = document.getElementById(`balanceAlert${programId}`);
    if (alertDiv) {
        const optimal = { push: 35, pull: 40, legs: 25 };
        const diff = {
            push: Math.abs(balance.percentages.push - optimal.push),
            pull: Math.abs(balance.percentages.pull - optimal.pull),
            legs: Math.abs(balance.percentages.legs - optimal.legs)
        };
        
        // Si un déséquilibre est supérieur à 10%
        const maxDiff = Math.max(diff.push, diff.pull, diff.legs);
        if (maxDiff > 10) {
            const underrepresented = Object.keys(diff).reduce((a, b) => 
                balance.percentages[a] < balance.percentages[b] ? a : b
            );
            
            alertDiv.innerHTML = `
                <strong>⚠️ Déséquilibre détecté:</strong> 
                Le groupe ${underrepresented.toUpperCase()} est sous-représenté de ${maxDiff}% par rapport à l'optimal.
                <br><em>💡 Conseil: Ajoute 1-2 séries d'exercices ${underrepresented} lors des prochaines séances.</em>
            `;
            alertDiv.classList.add('visible');
        } else {
            alertDiv.classList.remove('visible');
        }
    }
}

/**
 * Calcule l'indice de fatigue pour un programme donné
 * Indice = Volume Semaine 3 / Volume Semaine 1
 */
function calculateFatigueIndex(program) {
    // Obtenir toutes les dates de workout pour ce programme
    const workoutDates = [];
    Object.keys(workoutData).forEach(key => {
        const [keyProgram, workout, date] = key.split('_');
        if (keyProgram === program) {
            workoutDates.push(new Date(date));
        }
    });
    
    if (workoutDates.length === 0) {
        return { index: null, status: 'Pas assez de données' };
    }
    
    // Trier par date
    workoutDates.sort((a, b) => b - a);
    
    // Identifier le cycle actuel (dernières 3 semaines)
    const now = new Date();
    const threeWeeksAgo = new Date(now.getTime() - 21 * 24 * 60 * 60 * 1000);
    
    // Séparer en semaines
    const week1Dates = [];
    const week2Dates = [];
    const week3Dates = [];
    
    workoutDates.forEach(date => {
        if (date < threeWeeksAgo) return;
        
        const daysAgo = Math.floor((now - date) / (24 * 60 * 60 * 1000));
        
        if (daysAgo < 7) {
            week3Dates.push(date);
        } else if (daysAgo < 14) {
            week2Dates.push(date);
        } else if (daysAgo < 21) {
            week1Dates.push(date);
        }
    });
    
    // Calculer le volume de chaque semaine
    const calculateWeekVolume = (dates) => {
        let volume = 0;
        dates.forEach(date => {
            const dateStr = date.toISOString().split('T')[0];
            Object.keys(workoutData).forEach(key => {
                if (key.startsWith(program) && key.endsWith(dateStr)) {
                    const sessionData = workoutData[key];
                    const workout = key.split('_')[1];
                    const exercises = workouts[program][workout];
                    
                    if (!exercises) return;
                    
                    exercises.forEach((exercise, idx) => {
                        const exerciseData = sessionData[idx];
                        if (!exerciseData || !exerciseData.reps || !exerciseData.weight) return;
                        
                        const totalReps = exerciseData.reps.reduce((sum, r) => sum + (parseInt(r) || 0), 0);
                        volume += totalReps * (parseFloat(exerciseData.weight) || 0);
                    });
                }
            });
        });
        return volume;
    };
    
    const week1Volume = calculateWeekVolume(week1Dates);
    const week3Volume = calculateWeekVolume(week3Dates);
    
    if (week1Volume === 0 || week3Volume === 0) {
        return { index: null, status: 'Cycle incomplet' };
    }
    
    const index = (week3Volume / week1Volume).toFixed(2);
    
    // Déterminer le statut
    let status = '';
    let statusClass = '';
    
    if (index < 0.90) {
        status = '⚠️ Fatigue excessive - Envisage un deload';
        statusClass = 'warning';
    } else if (index >= 0.95 && index <= 1.05) {
        status = '✅ Récupération optimale';
        statusClass = 'optimal';
    } else if (index > 1.10) {
        status = '⚠️ Risque de surentraînement';
        statusClass = 'danger';
    } else {
        status = '✅ Fatigue normale';
        statusClass = 'optimal';
    }
    
    return { index, status, statusClass };
}

/**
 * Met à jour l'affichage de l'indice de fatigue
 */
function updateFatigueDisplay(program) {
    const programId = program === 'A' ? 'ProgramA' : 'ProgramB';
    const fatigue = calculateFatigueIndex(program);
    
    const indexElement = document.getElementById(`fatigueIndex${programId}`);
    const statusElement = document.getElementById(`fatigueStatus${programId}`);
    
    if (indexElement) {
        indexElement.textContent = fatigue.index !== null ? fatigue.index : '-';
    }
    
    if (statusElement) {
        statusElement.textContent = fatigue.status;
        statusElement.className = 'fatigue-status ' + (fatigue.statusClass || '');
    }
}

/**
 * Calcule les records (PRs) pour un programme donné
 */
function calculateRecords(program) {
    const records = {};
    
    // Parcourir toutes les données de workout
    Object.keys(workoutData).forEach(key => {
        const [keyProgram, workout, date] = key.split('_');
        
        // Ne traiter que le programme demandé
        if (keyProgram !== program) return;
        
        const sessionData = workoutData[key];
        const exercises = workouts[program][workout];
        
        if (!exercises) return;
        
        // Parcourir les exercices de la session
        exercises.forEach((exercise, idx) => {
            const exerciseData = sessionData[idx];
            if (!exerciseData || !exerciseData.reps || !exerciseData.weight) return;
            
            const exerciseName = exercise.name;
            const weight = parseFloat(exerciseData.weight);
            
            // Trouver le meilleur set (plus de reps avec ce poids)
            const maxReps = Math.max(...exerciseData.reps.map(r => parseInt(r) || 0));
            const volume = weight * maxReps;
            
            // Mettre à jour le record si c'est mieux
            if (!records[exerciseName] || volume > records[exerciseName].volume) {
                records[exerciseName] = {
                    weight,
                    reps: maxReps,
                    volume,
                    date,
                    category: categorizeExercise(exerciseName)
                };
            }
        });
    });
    
    return records;
}

/**
 * Met à jour l'affichage des records
 */
function updateRecordsDisplay(program) {
    const programId = program === 'A' ? 'ProgramA' : 'ProgramB';
    const records = calculateRecords(program);
    const gridElement = document.getElementById(`recordsGrid${programId}`);
    
    if (!gridElement) return;
    
    // Grouper les records par catégorie
    const recordsByCategory = {
        push: [],
        pull: [],
        legs: []
    };
    
    Object.entries(records).forEach(([name, record]) => {
        if (recordsByCategory[record.category]) {
            recordsByCategory[record.category].push({ name, ...record });
        }
    });
    
    // Générer le HTML
    let html = '';
    
    const categoryNames = {
        push: { emoji: '💪', name: 'Push (Poussée)' },
        pull: { emoji: '🔙', name: 'Pull (Traction)' },
        legs: { emoji: '🦵', name: 'Legs (Jambes)' }
    };
    
    Object.entries(recordsByCategory).forEach(([category, categoryRecords]) => {
        if (categoryRecords.length === 0) return;
        
        // Trier par volume décroissant
        categoryRecords.sort((a, b) => b.volume - a.volume);
        
        // Prendre les 5 meilleurs
        const top5 = categoryRecords.slice(0, 5);
        
        html += `
            <div class="record-category">
                <div class="record-category-title">
                    ${categoryNames[category].emoji} ${categoryNames[category].name}
                </div>
        `;
        
        top5.forEach((record, idx) => {
            const isRecent = new Date(record.date) > new Date(Date.now() - 14 * 24 * 60 * 60 * 1000);
            const badge = isRecent ? '<span class="record-badge">NOUVEAU</span>' : '';
            
            html += `
                <div class="record-item">
                    <div class="record-exercise">${record.name}</div>
                    <div style="display: flex; align-items: center;">
                        <span class="record-value">${record.weight}kg × ${record.reps}</span>
                        ${badge}
                        <span class="record-date">${new Date(record.date).toLocaleDateString('fr-FR')}</span>
                    </div>
                </div>
            `;
        });
        
        html += '</div>';
    });
    
    if (html === '') {
        html = '<p style="text-align: center; color: rgba(255,255,255,0.5);">Aucun record enregistré pour le moment.</p>';
    }
    
    gridElement.innerHTML = html;
}

/**
 * Fonction principale pour mettre à jour toutes les stats Phase 2
 */
function updatePhase2Stats() {
    // Mettre à jour pour Programme A
    updatePushPullLegsDisplay('A');
    updateFatigueDisplay('A');
    updateRecordsDisplay('A');
    
    // Mettre à jour pour Programme B
    updatePushPullLegsDisplay('B');
    updateFatigueDisplay('B');
    updateRecordsDisplay('B');
}

// Ajouter l'appel à updatePhase2Stats() dans la fonction updateStats() existante


// ========================================
// PHASE 3: INSIGHTS & PRÉDICTIONS
// ========================================

// Calculer les progressions par exercice
function calculateProgressions(workouts, program) {
    try {
        const exerciseStats = {};
    
    // Grouper par exercice
    workouts.forEach(workout => {
        workout.exercises.forEach(ex => {
            if (!exerciseStats[ex.name]) {
                exerciseStats[ex.name] = [];
            }
            
            const totalVolume = ex.sets.reduce((sum, set) => {
                return sum + (parseInt(set.reps) || 0) * (parseFloat(set.weight) || 0);
            }, 0);
            
            exerciseStats[ex.name].push({
                date: workout.date,
                volume: totalVolume,
                maxWeight: Math.max(...ex.sets.map(s => parseFloat(s.weight) || 0))
            });
        });
    });
    
    // Calculer les progressions
    const progressions = [];
    
    for (const [exercise, data] of Object.entries(exerciseStats)) {
        if (data.length < 2) continue;
        
        // Trier par date
        data.sort((a, b) => new Date(a.date) - new Date(b.date));
        
        const firstSession = data[0];
        const lastSession = data[data.length - 1];
        
        const volumeChange = ((lastSession.volume - firstSession.volume) / firstSession.volume) * 100;
        const weightChange = lastSession.maxWeight - firstSession.maxWeight;
        
        progressions.push({
            exercise,
            volumeChange: volumeChange.toFixed(1),
            weightChange: weightChange.toFixed(1),
            sessionsCount: data.length,
            trend: volumeChange > 0 ? 'up' : volumeChange < 0 ? 'down' : 'stable'
        });
    }
    
    return progressions.sort((a, b) => parseFloat(b.volumeChange) - parseFloat(a.volumeChange));
    } catch (error) {
        console.error('Erreur dans calculateProgressions:', error);
        return [];
    }
}

// Afficher les insights (top progressions et points d'attention)
function displayInsights(program) {
    try {
        const workouts = getWorkoutsByProgram(program);
        
        if (workouts.length < 3) {
            document.getElementById(`topProgressionsProgram${program}`).innerHTML = 
                '<div style="text-align: center; padding: 20px; color: rgba(255,255,255,0.6);">Pas assez de données (minimum 3 séances)</div>';
            document.getElementById(`attentionPointsProgram${program}`).innerHTML = 
                '<div style="text-align: center; padding: 20px; color: rgba(255,255,255,0.6);">Pas assez de données (minimum 3 séances)</div>';
            return;
        }
        
        const progressions = calculateProgressions(workouts, program);
    
    // Top 3 progressions
    const topProgressions = progressions.slice(0, 3).filter(p => parseFloat(p.volumeChange) > 0);
    const topHtml = topProgressions.length > 0
        ? topProgressions.map(p => `
            <div class="progression-item">
                <div class="progression-exercise">${p.exercise}</div>
                <div class="progression-change progression-positive">
                    📈 +${p.volumeChange}% volume | +${p.weightChange}kg
                </div>
                <div style="font-size: 0.85em; color: rgba(255,255,255,0.5); margin-top: 5px;">
                    ${p.sessionsCount} séances suivies
                </div>
            </div>
        `).join('')
        : '<div style="text-align: center; padding: 20px; color: rgba(255,255,255,0.6);">Aucune progression significative détectée</div>';
    
    document.getElementById(`topProgressionsProgram${program}`).innerHTML = topHtml;
    
    // Points d'attention (stagnation ou régression)
    const attentionPoints = progressions.filter(p => parseFloat(p.volumeChange) < -5).slice(0, 3);
    const attentionHtml = attentionPoints.length > 0
        ? attentionPoints.map(p => `
            <div class="attention-item">
                <div class="progression-exercise">${p.exercise}</div>
                <div class="progression-change progression-negative">
                    📉 ${p.volumeChange}% volume | ${p.weightChange}kg
                </div>
                <div style="font-size: 0.85em; color: rgba(255,255,255,0.5); margin-top: 5px;">
                    💡 Envisager une variation ou un deload
                </div>
            </div>
        `).join('')
        : '<div style="text-align: center; padding: 20px; color: rgba(255,255,255,0.6);">✅ Aucun point d\'attention majeur</div>';
    
    document.getElementById(`attentionPointsProgram${program}`).innerHTML = attentionHtml;
    } catch (error) {
        console.error('Erreur dans displayInsights:', error);
        const topEl = document.getElementById(`topProgressionsProgram${program}`);
        const attEl = document.getElementById(`attentionPointsProgram${program}`);
        if (topEl) topEl.innerHTML = '<div style="text-align: center; padding: 20px; color: rgba(255,255,255,0.6);">Erreur lors du chargement</div>';
        if (attEl) attEl.innerHTML = '<div style="text-align: center; padding: 20px; color: rgba(255,255,255,0.6);">Erreur lors du chargement</div>';
    }
}

// Calculer le ratio Libre vs Guidé pour exercices similaires
function displayRatioLibreGuide() {
    try {
        const workoutsA = getWorkoutsByProgram('A');
        const workoutsB = getWorkoutsByProgram('B');
    
    if (workoutsA.length < 2 || workoutsB.length < 2) {
        document.getElementById('ratioGridProgramA').innerHTML = 
            '<div class="prediction-empty">Pas assez de données dans les deux programmes</div>';
        return;
    }
    
    // Groupes d'exercices similaires
    const similarExercises = {
        'Développé couché': ['Développé couché', 'Bench press', 'Développé incliné'],
        'Squat': ['Squat', 'Front squat', 'Back squat'],
        'Soulevé de terre': ['Soulevé de terre', 'Deadlift', 'Romanian deadlift'],
        'Développé militaire': ['Développé militaire', 'Military press', 'Overhead press'],
        'Rowing': ['Rowing barre', 'Rowing', 'Barbell row']
    };
    
    const ratios = [];
    
    for (const [category, variations] of Object.entries(similarExercises)) {
        // Trouver les exercices dans chaque programme
        let volumeA = 0, countA = 0;
        let volumeB = 0, countB = 0;
        
        workoutsA.forEach(workout => {
            workout.exercises.forEach(ex => {
                if (variations.some(v => ex.name.toLowerCase().includes(v.toLowerCase()))) {
                    const vol = ex.sets.reduce((sum, set) => 
                        sum + (parseInt(set.reps) || 0) * (parseFloat(set.weight) || 0), 0);
                    volumeA += vol;
                    countA++;
                }
            });
        });
        
        workoutsB.forEach(workout => {
            workout.exercises.forEach(ex => {
                if (variations.some(v => ex.name.toLowerCase().includes(v.toLowerCase()))) {
                    const vol = ex.sets.reduce((sum, set) => 
                        sum + (parseInt(set.reps) || 0) * (parseFloat(set.weight) || 0), 0);
                    volumeB += vol;
                    countB++;
                }
            });
        });
        
        if (countA > 0 && countB > 0) {
            const avgA = volumeA / countA;
            const avgB = volumeB / countB;
            const ratio = (avgA / avgB).toFixed(2);
            
            let verdict = '';
            let verdictClass = '';
            if (Math.abs(ratio - 1) < 0.15) {
                verdict = '✅ Performances équilibrées';
                verdictClass = 'ratio-balanced';
            } else if (ratio > 1) {
                verdict = `💪 Libre ${((ratio - 1) * 100).toFixed(0)}% meilleur`;
                verdictClass = 'ratio-libre-better';
            } else {
                verdict = `🎯 Guidé ${((1 - ratio) * 100).toFixed(0)}% meilleur`;
                verdictClass = 'ratio-guide-better';
            }
            
            ratios.push({
                category,
                avgA: avgA.toFixed(0),
                avgB: avgB.toFixed(0),
                ratio,
                verdict,
                verdictClass
            });
        }
    }
    
    if (ratios.length === 0) {
        document.getElementById('ratioGridProgramA').innerHTML = 
            '<div class="prediction-empty">Aucun exercice similaire trouvé dans les deux programmes</div>';
        return;
    }
    
    const html = ratios.map(r => `
        <div class="ratio-card">
            <div class="ratio-exercise">${r.category}</div>
            <div class="ratio-comparison">
                <div class="ratio-program">
                    <div class="ratio-label">Programme A (Libre)</div>
                    <div class="ratio-value">${r.avgA}</div>
                </div>
                <div style="display: flex; align-items: center; color: rgba(255,255,255,0.5);">vs</div>
                <div class="ratio-program">
                    <div class="ratio-label">Programme B (Guidé)</div>
                    <div class="ratio-value">${r.avgB}</div>
                </div>
            </div>
            <div class="ratio-verdict ${r.verdictClass}">
                ${r.verdict}
            </div>
        </div>
    `).join('');
    
    document.getElementById('ratioGridProgramA').innerHTML = html;
    } catch (error) {
        console.error('Erreur dans displayRatioLibreGuide:', error);
        const el = document.getElementById('ratioGridProgramA');
        if (el) el.innerHTML = '<div class="prediction-empty">Erreur lors du chargement des données</div>';
    }
}

// Prédictions de performance (simple régression linéaire)
function displayPredictions(program) {
    try {
        const workouts = getWorkoutsByProgram(program);
    
    if (workouts.length < 4) {
        document.getElementById(`predictionsProgram${program}`).innerHTML = 
            '<div class="prediction-empty">Pas assez de données pour faire des prédictions (minimum 4 séances)</div>';
        return;
    }
    
    const exerciseData = {};
    
    // Collecter les données par exercice
    workouts.forEach(workout => {
        workout.exercises.forEach(ex => {
            if (!exerciseData[ex.name]) {
                exerciseData[ex.name] = [];
            }
            
            const maxWeight = Math.max(...ex.sets.map(s => parseFloat(s.weight) || 0));
            if (maxWeight > 0) {
                exerciseData[ex.name].push({
                    date: new Date(workout.date),
                    weight: maxWeight
                });
            }
        });
    });
    
    const predictions = [];
    
    for (const [exercise, data] of Object.entries(exerciseData)) {
        if (data.length < 3) continue;
        
        // Trier par date
        data.sort((a, b) => a.date - b.date);
        
        // Régression linéaire simple
        const n = data.length;
        const firstDate = data[0].date.getTime();
        const x = data.map((d, i) => i);
        const y = data.map(d => d.weight);
        
        const sumX = x.reduce((a, b) => a + b, 0);
        const sumY = y.reduce((a, b) => a + b, 0);
        const sumXY = x.reduce((sum, xi, i) => sum + xi * y[i], 0);
        const sumX2 = x.reduce((sum, xi) => sum + xi * xi, 0);
        
        const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
        const intercept = (sumY - slope * sumX) / n;
        
        // Prédire dans 4 semaines (28 jours)
        const currentWeight = y[y.length - 1];
        const avgSessionsPerWeek = n / ((data[n-1].date - data[0].date) / (1000 * 60 * 60 * 24 * 7));
        const futureSessions = Math.round(avgSessionsPerWeek * 4);
        const predictedWeight = slope * (n + futureSessions) + intercept;
        
        if (predictedWeight > currentWeight) {
            predictions.push({
                exercise,
                current: currentWeight.toFixed(1),
                predicted: predictedWeight.toFixed(1),
                gain: (predictedWeight - currentWeight).toFixed(1),
                weeks: 4
            });
        }
    }
    
    // Trier par gain prédit
    predictions.sort((a, b) => parseFloat(b.gain) - parseFloat(a.gain));
    
    if (predictions.length === 0) {
        document.getElementById(`predictionsProgram${program}`).innerHTML = 
            '<div class="prediction-empty">Aucune prédiction positive disponible</div>';
        return;
    }
    
    const html = predictions.slice(0, 6).map(p => `
        <div class="prediction-card">
            <div class="prediction-exercise">${p.exercise}</div>
            <div class="prediction-current">Actuel: ${p.current}kg</div>
            <div class="prediction-target">🎯 Prédit: ${p.predicted}kg (+${p.gain}kg)</div>
            <div class="prediction-timeline">⏱️ Dans ${p.weeks} semaines</div>
        </div>
    `).join('');
    
    document.getElementById(`predictionsProgram${program}`).innerHTML = html;
    } catch (error) {
        console.error('Erreur dans displayPredictions:', error);
        const el = document.getElementById(`predictionsProgram${program}`);
        if (el) el.innerHTML = '<div class="prediction-empty">Erreur lors du chargement des données</div>';
    }
}

// Fonction helper pour récupérer les workouts par programme
function getWorkoutsByProgram(program) {
    try {
        const workoutsArray = [];
        
        // Utiliser workoutData comme les fonctions Phase 2
        Object.keys(workoutData).forEach(key => {
        const [keyProgram, workout, date] = key.split('_');
        
        // Ne traiter que le programme demandé
        if (keyProgram !== program) return;
        
        const sessionData = workoutData[key];
        const exerciseTemplates = workouts[program][workout];
        
        if (!exerciseTemplates) return;
        
        // Construire un objet workout avec exercises
        const workoutObj = {
            date: date,
            type: workout,
            exercises: []
        };
        
        // Parcourir les exercices de la session
        exerciseTemplates.forEach((exercise, idx) => {
            const exerciseData = sessionData[idx];
            if (!exerciseData) return;
            
            // Construire la structure attendue par calculateProgressions
            const sets = [];
            if (exerciseData.reps && exerciseData.weight) {
                for (let i = 0; i < exerciseData.reps.length; i++) {
                    sets.push({
                        reps: exerciseData.reps[i],
                        weight: exerciseData.weight
                    });
                }
            }
            
            workoutObj.exercises.push({
                name: exercise.name,
                sets: sets
            });
        });
        
        workoutsArray.push(workoutObj);
    });
    
    return workoutsArray.sort((a, b) => new Date(a.date) - new Date(b.date));
    } catch (error) {
        console.error('Erreur dans getWorkoutsByProgram:', error);
        return [];
    }
}

// Mettre à jour toutes les stats Phase 3
function updatePhase3Stats() {
    try {
        // Programme A
        displayInsights('A');
        displayRatioLibreGuide();
        displayPredictions('A');
        
        // Programme B
        displayInsights('B');
        displayPredictions('B');
    } catch (error) {
        console.error('Erreur dans updatePhase3Stats:', error);
    }
}


</script>

</body>
</html>

